<?xml version='1.0'?>
<!-- NOTE: this file is autogenerated by Apache XBean -->

<xs:schema elementFormDefault='qualified'
           targetNamespace='http://activemq.apache.org/schema/core'
           xmlns:xs='http://www.w3.org/2001/XMLSchema'
           xmlns:tns='http://activemq.apache.org/schema/core'>

  <!-- element for type: org.apache.activemq.broker.region.policy.AbortSlowAckConsumerStrategy -->
  <xs:element name='abortSlowAckConsumerStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Abort slow consumers when they reach the configured threshold of slowness,

default is that a consumer that has not Ack'd a message for 30 seconds is slow.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='abortConnection' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            abort the consumers connection rather than sending a stop command to the remote consumer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkPeriod' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            time in milliseconds between checks for slow subscriptions
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='ignoreIdleConsumers' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns whether the strategy is configured to ignore consumers that are simply idle, i.e
consumers that have no pending acks (dispatch queue is empty).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='ignoreNetworkConsumers' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the strategy is configured to ignore consumers that are part of a network
connection to another broker.

When configured to not ignore idle consumers this strategy acts not only on consumers
that are actually slow but also on any consumer that has not received any messages for
the maxTimeSinceLastAck.  This allows for a way to evict idle consumers while also
aborting slow consumers however for a network subscription this can create a lot of
unnecessary churn and if the abort connection option is also enabled this can result
in the entire network connection being torn down and rebuilt for no reason.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxSlowCount' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            number of times a subscription can be deemed slow before triggering abort
effect depends on dispatch rate as slow determination is done on dispatch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxSlowDuration' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            time in milliseconds that a sub can remain slow before triggering
an abort.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxTimeSinceLastAck' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the maximum time since last Ack before a subscription is considered to be slow.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy -->
  <xs:element name='abortSlowConsumerStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='abortConnection' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            abort the consumers connection rather than sending a stop command to the remote consumer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkPeriod' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            time in milliseconds between checks for slow subscriptions
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='ignoreNetworkConsumers' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the strategy is configured to ignore consumers that are part of a network
connection to another broker.

When configured to not ignore idle consumers this strategy acts not only on consumers
that are actually slow but also on any consumer that has not received any messages for
the maxTimeSinceLastAck.  This allows for a way to evict idle consumers while also
aborting slow consumers however for a network subscription this can create a lot of
unnecessary churn and if the abort connection option is also enabled this can result
in the entire network connection being torn down and rebuilt for no reason.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxSlowCount' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            number of times a subscription can be deemed slow before triggering abort
effect depends on dispatch rate as slow determination is done on dispatch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxSlowDuration' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            time in milliseconds that a sub can remain slow before triggering
an abort.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.AuthenticationUser -->
  <xs:element name='authenticationUser'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A helper object used to configure simple authentication plugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='groups' type='xs:string'/>
      <xs:attribute name='password' type='xs:string'/>
      <xs:attribute name='username' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.XBeanAuthorizationEntry -->
  <xs:element name='authorizationEntry'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an entry in a {@link DefaultAuthorizationMap} for assigning
different operations (read, write, admin) of user roles to a specific
destination or a hierarchical wildcard area of destinations.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='readACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='writeACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='admin' type='xs:string'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='groupClass' type='xs:string'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='read' type='xs:string'/>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='write' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.XBeanAuthorizationMap -->
  <xs:element name='authorizationMap'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='authorizationEntries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the individual entries on the authorization map
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationEntry'/>
              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='entries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A helper method to allow the destination map to be populated from a
dependency injection framework such as Spring
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempDestinationAuthorizationEntry' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='defaultEntry' type='xs:string'/>
      <xs:attribute name='groupClass' type='xs:string'/>
      <xs:attribute name='tempDestinationAuthorizationEntry' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.AuthorizationPlugin -->
  <xs:element name='authorizationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An authorization plugin where each operation on a destination is checked
against an authorizationMap
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='map' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationMap'/>
              <xs:element ref='tns:cachedLDAPAuthorizationMap'/>
              <xs:element ref='tns:lDAPAuthorizationMap'/>
              <xs:element ref='tns:simpleAuthorizationMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='map' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.AxionJDBCAdapter -->
  <xs:element name='axionJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Axion specific Adapter.

Axion does not seem to support ALTER statements or sub-selects.  This means:
- We cannot auto upgrade the schema was we roll out new versions of ActiveMQ
- We cannot delete durable sub messages that have be acknowledged by all consumers.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.BlobJDBCAdapter -->
  <xs:element name='blobJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This JDBCAdapter inserts and extracts BLOB data using the getBlob()/setBlob()
operations. This is a little more involved since to insert a blob you have
to:

1: insert empty blob. 2: select the blob 3: finally update the blob with data
value.

The databases/JDBC drivers that use this adapter are:
<ul>
<li></li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.xbean.XBeanBrokerService -->
  <xs:element name='broker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ActiveMQ Message Broker. It consists of a number of transport
connectors, network connectors and a bunch of properties which can be used to
configure the broker as its lazily created.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminView' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Returns the administration view of the broker; used to create and destroy
resources such as queues and topics. Note this method returns null if JMX
is disabled.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerSystemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationInterceptors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destination interceptors to use
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:mirroredQueue'/>
              <xs:element ref='tns:virtualDestinationInterceptor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destination specific policies available either for exact
destinations or for wildcard areas of destinations.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:policyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destinations which should be loaded/created on startup
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='ioExceptionHandler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              override the Default IOException handler, called when persistence adapter
has experiences File or JDBC I/O Exceptions
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultIOExceptionHandler'/>
              <xs:element ref='tns:jDBCIOExceptionHandler'/>
              <xs:element ref='tns:leaseLockerIOExceptionHandler'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsBridgeConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jobSchedulerStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='managementContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:managementContext'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to decide if the current connection is authorized to
consume a given message
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkConnectorURIs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the network connectors which this broker will use to connect to
other brokers in a federated network
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the persistence adaptor implementation to use for this broker
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceTaskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='plugins' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets a number of broker plugins to install such as for security
authentication or authorization
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:authorizationPlugin'/>
              <xs:element ref='tns:camelRoutesBrokerPlugin'/>
              <xs:element ref='tns:connectionDotFilePlugin'/>
              <xs:element ref='tns:destinationDotFilePlugin'/>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:discardingDLQBrokerPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBrokerPlugin'/>
              <xs:element ref='tns:jaasAuthenticationPlugin'/>
              <xs:element ref='tns:jaasCertificateAuthenticationPlugin'/>
              <xs:element ref='tns:jaasDualAuthenticationPlugin'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:partitionBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:runtimeConfigurationPlugin'/>
              <xs:element ref='tns:simpleAuthenticationPlugin'/>
              <xs:element ref='tns:statisticsBrokerPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:element ref='tns:virtualSelectorCacheBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerSystemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='proxyConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the network connectors which this broker will use to connect to
other brokers in a federated network
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='regionBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='services' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the services associated with this broker.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:forwardingBridge'/>
              <xs:element ref='tns:inboundQueueBridge'/>
              <xs:element ref='tns:inboundTopicBridge'/>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:element ref='tns:jobSchedulerUsage'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:managementContext'/>
              <xs:element ref='tns:memoryUsage'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:element ref='tns:outboundQueueBridge'/>
              <xs:element ref='tns:outboundTopicBridge'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:proxyConnector'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:storeUsage'/>
              <xs:element ref='tns:systemUsage'/>
              <xs:element ref='tns:tempUsage'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='shutdownHooks' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets hooks to be executed when broker shut down
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sslContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:sslContext'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='systemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempDataStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportConnectorURIs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the transport connectors which this broker will listen on for new
clients
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:transportConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminView' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the administration view of the broker; used to create and destroy
resources such as queues and topics. Note this method returns null if JMX
is disabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='advisorySupport' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows the support of advisory messages to be disabled for performance
reasons.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='allowTempAutoCreationOnSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            enable if temp destinations need to be propagated through a network when
advisorySupport==false. This is used in conjunction with the policy
gcInactiveDestinations for matching temps so they can get removed
when inactive
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerContext' type='xs:string'/>
      <xs:attribute name='brokerId' type='xs:string'/>
      <xs:attribute name='brokerName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of this broker; which must be unique in the network
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerObjectName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMX ObjectName for this broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='cacheTempDestinations' type='xs:boolean'/>
      <xs:attribute name='consumerSystemUsage' type='xs:string'/>
      <xs:attribute name='consumerSystemUsagePortion' type='xs:integer'/>
      <xs:attribute name='dataDirectory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the directory in which the data files will be stored by default for
the JDBC and Journal persistence adaptors.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dataDirectoryFile' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the directory in which the data files will be stored by default for
the JDBC and Journal persistence adaptors.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='deleteAllMessagesOnStartup' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not all messages are deleted on startup - mostly only
useful for testing.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='destinationFactory' type='xs:string'/>
      <xs:attribute name='destinationPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination specific policies available either for exact
destinations or for wildcard areas of destinations.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='diskUsageCheckRegrowThreshold' type='xs:string'/>
      <xs:attribute name='enableStatistics' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the Broker's services enable statistics or not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='ioExceptionHandler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            override the Default IOException handler, called when persistence adapter
has experiences File or JDBC I/O Exceptions
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='jobSchedulerStore' type='xs:string'/>
      <xs:attribute name='keepDurableSubsActive' type='xs:boolean'/>
      <xs:attribute name='managementContext' type='xs:string'/>
      <xs:attribute name='maxPurgedDestinationsPerSweep' type='xs:integer'/>
      <xs:attribute name='mbeanInvocationTimeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the time in Milliseconds that an invocation of an MBean method will wait before
failing.  The default value is to wait forever (zero).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to decide if the current connection is authorized to
consume a given message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='monitorConnectionSplits' type='xs:boolean'/>
      <xs:attribute name='networkConnectorStartAsync' type='xs:boolean'/>
      <xs:attribute name='offlineDurableSubscriberTaskSchedule' type='xs:long'/>
      <xs:attribute name='offlineDurableSubscriberTimeout' type='xs:long'/>
      <xs:attribute name='passiveSlave' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the passiveSlave
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='persistenceAdapter' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the persistence adaptor implementation to use for this broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='persistenceFactory' type='xs:string'/>
      <xs:attribute name='persistenceTaskRunnerFactory' type='xs:string'/>
      <xs:attribute name='persistenceThreadPriority' type='xs:integer'/>
      <xs:attribute name='persistent' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not persistence is enabled or disabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='populateJMSXUserID' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the broker should populate the JMSXUserID header.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='populateUserNameInMBeans' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should MBeans that support showing the Authenticated User Name information have this
value filled in or not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerSystemUsage' type='xs:string'/>
      <xs:attribute name='producerSystemUsagePortion' type='xs:integer'/>
      <xs:attribute name='regionBroker' type='xs:string'/>
      <xs:attribute name='rejectDurableConsumers' type='xs:boolean'/>
      <xs:attribute name='restartAllowed' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets if the broker allowed to restart on shutdown.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='schedulePeriodForDestinationPurge' type='xs:integer'/>
      <xs:attribute name='schedulePeriodForDiskUsageCheck' type='xs:integer'/>
      <xs:attribute name='schedulerDirectory' type='xs:string'/>
      <xs:attribute name='schedulerDirectoryFile' type='xs:string'/>
      <xs:attribute name='schedulerSupport' type='xs:string'/>
      <xs:attribute name='shutdownOnMasterFailure' type='xs:boolean'/>
      <xs:attribute name='shutdownOnSlaveFailure' type='xs:string'/>
      <xs:attribute name='splitSystemUsageForProducersConsumers' type='xs:boolean'/>
      <xs:attribute name='sslContext' type='xs:string'/>
      <xs:attribute name='start' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the broker is started along with the ApplicationContext it is defined within.
Normally you would want the broker to start up along with the ApplicationContext but sometimes when working
with JUnit tests you may wish to start and stop the broker explicitly yourself.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='startAsync' type='xs:boolean'/>
      <xs:attribute name='storeOpenWireVersion' type='xs:integer'/>
      <xs:attribute name='systemExitOnShutdown' type='xs:string'/>
      <xs:attribute name='systemExitOnShutdownExitCode' type='xs:integer'/>
      <xs:attribute name='systemUsage' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='taskRunnerPriority' type='xs:integer'/>
      <xs:attribute name='tempDataStore' type='xs:string'/>
      <xs:attribute name='timeBeforePurgeTempDestinations' type='xs:integer'/>
      <xs:attribute name='tmpDataDirectory' type='xs:string'/>
      <xs:attribute name='useAuthenticatedPrincipalForJMSXUserID' type='xs:boolean'/>
      <xs:attribute name='useJmx' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the Broker's services should be exposed into JMX or
not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useLocalHostBrokerName' type='xs:boolean'/>
      <xs:attribute name='useLoggingForShutdownErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not we should use commons-logging when reporting errors
when shutting down the broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useMirroredQueues' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not <a
href="http://activemq.apache.org/mirrored-queues.html">Mirrored
Queues</a> should be supported by default if they have not been
explicitly configured.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useShutdownHook' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not we should use a shutdown handler to close down the
broker cleanly if the JVM is terminated. It is recommended you leave this
enabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useTempMirroredQueues' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubs' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubsOnCreation' type='xs:boolean'/>
      <xs:attribute name='useVirtualTopics' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not <a
href="http://activemq.apache.org/virtual-destinations.html">Virtual
Topics</a> should be supported by default if they have not been
explicitly configured.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='vmConnectorURI' type='xs:string'/>
      <xs:attribute name='waitForSlave' type='xs:string'/>
      <xs:attribute name='waitForSlaveTimeout' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.BrokerService -->
  <xs:element name='brokerService'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Manages the life-cycle of an ActiveMQ Broker. A BrokerService consists of a
number of transport connectors, network connectors and a bunch of properties
which can be used to configure the broker as its lazily created.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminView' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Returns the administration view of the broker; used to create and destroy
resources such as queues and topics. Note this method returns null if JMX
is disabled.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerSystemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationInterceptors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destination interceptors to use
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:mirroredQueue'/>
              <xs:element ref='tns:virtualDestinationInterceptor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinationPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destination specific policies available either for exact
destinations or for wildcard areas of destinations.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:policyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the destinations which should be loaded/created on startup
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='ioExceptionHandler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              override the Default IOException handler, called when persistence adapter
has experiences File or JDBC I/O Exceptions
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultIOExceptionHandler'/>
              <xs:element ref='tns:jDBCIOExceptionHandler'/>
              <xs:element ref='tns:leaseLockerIOExceptionHandler'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsBridgeConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jobSchedulerStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='managementContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:managementContext'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to decide if the current connection is authorized to
consume a given message
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkConnectorURIs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the network connectors which this broker will use to connect to
other brokers in a federated network
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the persistence adaptor implementation to use for this broker
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceTaskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='plugins' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets a number of broker plugins to install such as for security
authentication or authorization
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:authorizationPlugin'/>
              <xs:element ref='tns:camelRoutesBrokerPlugin'/>
              <xs:element ref='tns:connectionDotFilePlugin'/>
              <xs:element ref='tns:destinationDotFilePlugin'/>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:discardingDLQBrokerPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBrokerPlugin'/>
              <xs:element ref='tns:jaasAuthenticationPlugin'/>
              <xs:element ref='tns:jaasCertificateAuthenticationPlugin'/>
              <xs:element ref='tns:jaasDualAuthenticationPlugin'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:partitionBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:runtimeConfigurationPlugin'/>
              <xs:element ref='tns:simpleAuthenticationPlugin'/>
              <xs:element ref='tns:statisticsBrokerPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:element ref='tns:virtualSelectorCacheBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerSystemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='proxyConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the network connectors which this broker will use to connect to
other brokers in a federated network
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='regionBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='services' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the services associated with this broker.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:forwardingBridge'/>
              <xs:element ref='tns:inboundQueueBridge'/>
              <xs:element ref='tns:inboundTopicBridge'/>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:element ref='tns:jobSchedulerUsage'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:managementContext'/>
              <xs:element ref='tns:memoryUsage'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:element ref='tns:outboundQueueBridge'/>
              <xs:element ref='tns:outboundTopicBridge'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:proxyConnector'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:storeUsage'/>
              <xs:element ref='tns:systemUsage'/>
              <xs:element ref='tns:tempUsage'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='shutdownHooks' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets hooks to be executed when broker shut down
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sslContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:sslContext'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='systemUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempDataStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportConnectorURIs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportConnectors' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the transport connectors which this broker will listen on for new
clients
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:transportConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminView' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the administration view of the broker; used to create and destroy
resources such as queues and topics. Note this method returns null if JMX
is disabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='advisorySupport' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows the support of advisory messages to be disabled for performance
reasons.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='allowTempAutoCreationOnSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            enable if temp destinations need to be propagated through a network when
advisorySupport==false. This is used in conjunction with the policy
gcInactiveDestinations for matching temps so they can get removed
when inactive
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerContext' type='xs:string'/>
      <xs:attribute name='brokerId' type='xs:string'/>
      <xs:attribute name='brokerName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of this broker; which must be unique in the network
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerObjectName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMX ObjectName for this broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='cacheTempDestinations' type='xs:boolean'/>
      <xs:attribute name='consumerSystemUsage' type='xs:string'/>
      <xs:attribute name='consumerSystemUsagePortion' type='xs:integer'/>
      <xs:attribute name='dataDirectory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the directory in which the data files will be stored by default for
the JDBC and Journal persistence adaptors.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dataDirectoryFile' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the directory in which the data files will be stored by default for
the JDBC and Journal persistence adaptors.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='deleteAllMessagesOnStartup' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not all messages are deleted on startup - mostly only
useful for testing.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='destinationFactory' type='xs:string'/>
      <xs:attribute name='destinationPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination specific policies available either for exact
destinations or for wildcard areas of destinations.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='diskUsageCheckRegrowThreshold' type='xs:string'/>
      <xs:attribute name='enableStatistics' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the Broker's services enable statistics or not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='ioExceptionHandler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            override the Default IOException handler, called when persistence adapter
has experiences File or JDBC I/O Exceptions
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='jobSchedulerStore' type='xs:string'/>
      <xs:attribute name='keepDurableSubsActive' type='xs:boolean'/>
      <xs:attribute name='managementContext' type='xs:string'/>
      <xs:attribute name='maxPurgedDestinationsPerSweep' type='xs:integer'/>
      <xs:attribute name='mbeanInvocationTimeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the time in Milliseconds that an invocation of an MBean method will wait before
failing.  The default value is to wait forever (zero).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to decide if the current connection is authorized to
consume a given message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='monitorConnectionSplits' type='xs:boolean'/>
      <xs:attribute name='networkConnectorStartAsync' type='xs:boolean'/>
      <xs:attribute name='offlineDurableSubscriberTaskSchedule' type='xs:long'/>
      <xs:attribute name='offlineDurableSubscriberTimeout' type='xs:long'/>
      <xs:attribute name='passiveSlave' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the passiveSlave
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='persistenceAdapter' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the persistence adaptor implementation to use for this broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='persistenceFactory' type='xs:string'/>
      <xs:attribute name='persistenceTaskRunnerFactory' type='xs:string'/>
      <xs:attribute name='persistenceThreadPriority' type='xs:integer'/>
      <xs:attribute name='persistent' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not persistence is enabled or disabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='populateJMSXUserID' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the broker should populate the JMSXUserID header.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='populateUserNameInMBeans' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should MBeans that support showing the Authenticated User Name information have this
value filled in or not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerSystemUsage' type='xs:string'/>
      <xs:attribute name='producerSystemUsagePortion' type='xs:integer'/>
      <xs:attribute name='regionBroker' type='xs:string'/>
      <xs:attribute name='rejectDurableConsumers' type='xs:boolean'/>
      <xs:attribute name='restartAllowed' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets if the broker allowed to restart on shutdown.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='schedulePeriodForDestinationPurge' type='xs:integer'/>
      <xs:attribute name='schedulePeriodForDiskUsageCheck' type='xs:integer'/>
      <xs:attribute name='schedulerDirectory' type='xs:string'/>
      <xs:attribute name='schedulerDirectoryFile' type='xs:string'/>
      <xs:attribute name='schedulerSupport' type='xs:string'/>
      <xs:attribute name='shutdownOnMasterFailure' type='xs:boolean'/>
      <xs:attribute name='shutdownOnSlaveFailure' type='xs:string'/>
      <xs:attribute name='splitSystemUsageForProducersConsumers' type='xs:boolean'/>
      <xs:attribute name='sslContext' type='xs:string'/>
      <xs:attribute name='startAsync' type='xs:boolean'/>
      <xs:attribute name='storeOpenWireVersion' type='xs:integer'/>
      <xs:attribute name='systemExitOnShutdown' type='xs:string'/>
      <xs:attribute name='systemExitOnShutdownExitCode' type='xs:integer'/>
      <xs:attribute name='systemUsage' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='taskRunnerPriority' type='xs:integer'/>
      <xs:attribute name='tempDataStore' type='xs:string'/>
      <xs:attribute name='timeBeforePurgeTempDestinations' type='xs:integer'/>
      <xs:attribute name='tmpDataDirectory' type='xs:string'/>
      <xs:attribute name='useAuthenticatedPrincipalForJMSXUserID' type='xs:boolean'/>
      <xs:attribute name='useJmx' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not the Broker's services should be exposed into JMX or
not.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useLocalHostBrokerName' type='xs:boolean'/>
      <xs:attribute name='useLoggingForShutdownErrors' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not we should use commons-logging when reporting errors
when shutting down the broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useMirroredQueues' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not <a
href="http://activemq.apache.org/mirrored-queues.html">Mirrored
Queues</a> should be supported by default if they have not been
explicitly configured.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useShutdownHook' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not we should use a shutdown handler to close down the
broker cleanly if the JVM is terminated. It is recommended you leave this
enabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useTempMirroredQueues' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubs' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubsOnCreation' type='xs:boolean'/>
      <xs:attribute name='useVirtualTopics' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not <a
href="http://activemq.apache.org/virtual-destinations.html">Virtual
Topics</a> should be supported by default if they have not been
explicitly configured.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='vmConnectorURI' type='xs:string'/>
      <xs:attribute name='waitForSlave' type='xs:string'/>
      <xs:attribute name='waitForSlaveTimeout' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.BytesJDBCAdapter -->
  <xs:element name='bytesJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This JDBCAdapter inserts and extracts BLOB data using the
setBytes()/getBytes() operations. The databases/JDBC drivers that use this
adapter are:
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.CachedLDAPAuthorizationMap -->
  <xs:element name='cachedLDAPAuthorizationMap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
policy.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='adminPermissionGroupSearchFilter' type='xs:string'/>
      <xs:attribute name='authentication' type='xs:string'/>
      <xs:attribute name='connectionPassword' type='xs:string'/>
      <xs:attribute name='connectionProtocol' type='xs:string'/>
      <xs:attribute name='connectionURL' type='xs:string'/>
      <xs:attribute name='connectionUsername' type='xs:string'/>
      <xs:attribute name='groupClass' type='xs:string'/>
      <xs:attribute name='groupNameAttribute' type='xs:string'/>
      <xs:attribute name='groupObjectClass' type='xs:string'/>
      <xs:attribute name='legacyGroupMapping' type='xs:boolean'/>
      <xs:attribute name='permissionGroupMemberAttribute' type='xs:string'/>
      <xs:attribute name='queueSearchBase' type='xs:string'/>
      <xs:attribute name='readPermissionGroupSearchFilter' type='xs:string'/>
      <xs:attribute name='refreshDisabled' type='xs:boolean'/>
      <xs:attribute name='refreshInterval' type='xs:integer'/>
      <xs:attribute name='tempSearchBase' type='xs:string'/>
      <xs:attribute name='topicSearchBase' type='xs:string'/>
      <xs:attribute name='userNameAttribute' type='xs:string'/>
      <xs:attribute name='userObjectClass' type='xs:string'/>
      <xs:attribute name='writePermissionGroupSearchFilter' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.group.CachedMessageGroupMapFactory -->
  <xs:element name='cachedMessageGroupMapFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A factory to create instances of {@link org.apache.activemq.broker.region.group.CachedMessageGroupMap} when implementing the
<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='cacheSize' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.camel.component.CamelEndpointLoader -->
  <xs:element name='camelEndpointLoader'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A helper bean which populates a {@link CamelContext} with ActiveMQ Queue endpoints
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='camelContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='component' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='source' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='camelContext' type='xs:string'/>
      <xs:attribute name='component' type='xs:string'/>
      <xs:attribute name='source' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.camel.camelplugin.CamelRoutesBrokerPlugin -->
  <xs:element name='camelRoutesBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A CamelRoutesBrokerPlugin

load camel routes dynamically from a routes.xml file located in same directory as ActiveMQ.xml
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='checkPeriod' type='xs:integer'/>
      <xs:attribute name='routesFile' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.CompositeDemandForwardingBridge -->
  <xs:element name='compositeDemandForwardingBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A demand forwarding bridge which works with multicast style transports where
a single Transport could be communicating with multiple remote brokers
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='configuration' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkBridgeListener' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='configuration' type='xs:string'/>
      <xs:attribute name='createdByDuplex' type='xs:boolean'/>
      <xs:attribute name='localBroker' type='xs:string'/>
      <xs:attribute name='mbeanObjectName' type='xs:string'/>
      <xs:attribute name='networkBridgeListener' type='xs:string'/>
      <xs:attribute name='remoteBroker' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.CompositeQueue -->
  <xs:element name='compositeQueue'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents a virtual queue which forwards to a number of other destinations.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='forwardTo' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the list of destinations to forward to
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='concurrentSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            when true, sends are done in parallel with the broker executor
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyMessage' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether a copy of the message will be sent to each destination.
Defaults to true so that the forward destination is set as the
destination of the message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forwardOnly' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets if the virtual destination is forward only (and so there is no
physical queue to match the virtual queue) or if there is also a physical
queue with the same name).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of this composite destination
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.CompositeTopic -->
  <xs:element name='compositeTopic'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents a virtual topic which forwards to a number of other destinations.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='forwardTo' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the list of destinations to forward to
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='concurrentSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            when true, sends are done in parallel with the broker executor
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='copyMessage' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether a copy of the message will be sent to each destination.
Defaults to true so that the forward destination is set as the
destination of the message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forwardOnly' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets if the virtual destination is forward only (and so there is no
physical queue to match the virtual queue) or if there is also a physical
queue with the same name).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of this composite destination
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.ConditionalNetworkBridgeFilterFactory -->
  <xs:element name='conditionalNetworkBridgeFilterFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        implement conditional behavior for queue consumers, allows replaying back to
origin if no consumers are present on the local broker after a configurable
delay, irrespective of the TTL. Also allows rate limiting of messages
through the network, useful for static includes
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='rateDuration' type='xs:integer'/>
      <xs:attribute name='rateLimit' type='xs:integer'/>
      <xs:attribute name='replayDelay' type='xs:integer'/>
      <xs:attribute name='replayWhenNoConsumers' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.view.ConnectionDotFilePlugin -->
  <xs:element name='connectionDotFilePlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A <a href="http://www.graphviz.org/">DOT</a> file creator plugin which
creates a DOT file showing the current connections
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='file' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination file name to create the destination diagram
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.spring.ActiveMQConnectionFactory -->
  <xs:element name='connectionFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A <a href="http://www.springframework.org/">Spring</a> enhanced connection
factory which will automatically use the Spring bean name as the clientIDPrefix property
so that connections created have client IDs related to your Spring.xml file for
easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='blobTransferPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to describe how out-of-band BLOBs (Binary Large
OBjects) are transferred from producers to brokers to consumers
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='clientIdGenerator' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='clientInternalExceptionListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='connectionIdGenerator' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='exceptionListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='prefetchPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the <a
href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
policy</a> for consumers created by this connection.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:prefetchPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the global default redelivery policy to be used when a message is delivered
but the session is rolled back
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the global redelivery policy mapping to be used when a message is delivered
but the session is rolled back
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionTaskRunner' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the transformer used to transform messages before they are sent on
to the JMS bus or when they are received from the bus but before they are
delivered to the JMS client
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows a listener to be configured on the ConnectionFactory so that when this factory is used
with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
a transport listener.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='alwaysSessionAsync' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this flag is not set then a separate thread is not used for dispatching messages for each Session in
the Connection. However, a separate thread is always used if there is more than one session, or the session
isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
happens asynchronously.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='alwaysSyncSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set true if always require messages to be sync sent
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='auditDepth' type='xs:integer'/>
      <xs:attribute name='auditMaximumProducerNumber' type='xs:integer'/>
      <xs:attribute name='beanName' type='xs:string'/>
      <xs:attribute name='blobTransferPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to describe how out-of-band BLOBs (Binary Large
OBjects) are transferred from producers to brokers to consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerURL' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the <a
href="http://activemq.apache.org/configuring-transports.html">connection
URL</a> used to connect to the ActiveMQ broker.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='checkForDuplicates' type='xs:boolean'/>
      <xs:attribute name='clientID' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS clientID to use for the created connection. Note that this
can only be used by one connection at once so generally its a better idea
to set the clientID on a Connection
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='clientIDPrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix used by autogenerated JMS Client ID values which are used
if the JMS client does not explicitly specify on.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='clientIdGenerator' type='xs:string'/>
      <xs:attribute name='clientInternalExceptionListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='closeTimeout' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the timeout before a close is considered complete. Normally a
close() on a connection waits for confirmation from the broker; this
allows that operation to timeout to save the client hanging if there is
no broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectionIDPrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix used by connection id generator
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectionIdGenerator' type='xs:string'/>
      <xs:attribute name='consumerExpiryCheckEnabled' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Controls whether message expiration checking is done in each MessageConsumer
prior to dispatching a message.  Disabling this check can lead to consumption
of expired messages.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='consumerFailoverRedeliveryWaitPeriod' type='xs:long'/>
      <xs:attribute name='copyMessageOnSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should a JMS message be copied to a new JMS Message object as part of the
send() method in JMS. This is enabled by default to be compliant with the
JMS specification. You can disable it if you do not mutate JMS messages
after they are sent for a performance boost
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='disableTimeStampsByDefault' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not timestamps on messages should be disabled or not. If
you disable them it adds a small performance boost.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dispatchAsync' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the default setting of whether or not consumers have
their messages <a
href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
synchronously or asynchronously by the broker</a>. For non-durable
topics for example we typically dispatch synchronously by default to
minimize context switches which boost performance. However sometimes its
better to go slower to ensure that a single blocked consumer socket does
not block delivery to other consumers.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='exceptionListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='exclusiveConsumer' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables whether or not queue consumers should be exclusive or
not for example to preserve ordering when not using <a
href="http://activemq.apache.org/message-groups.html">Message Groups</a>
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
      <xs:attribute name='messagePrioritySupported' type='xs:boolean'/>
      <xs:attribute name='nestedMapAndListEnabled' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables/disables whether or not Message properties and MapMessage entries
support <a
href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
Structures</a> of Map and List objects
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='nonBlockingRedelivery' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When true a MessageConsumer will not stop Message delivery before re-delivering Messages
from a rolled back transaction.  This implies that message order will not be preserved and
also will result in the TransactedIndividualAck option to be enabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='objectMessageSerializationDefered' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When an object is set on an ObjectMessage, the JMS spec requires the
object to be serialized by that set method. Enabling this flag causes the
object to not get serialized. The object may subsequently get serialized
if the message needs to be sent over a socket or stored to disk.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizeAcknowledge' type='xs:boolean'/>
      <xs:attribute name='optimizeAcknowledgeTimeOut' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The max time in milliseconds between optimized ack batches
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizedAckScheduledAckInterval' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
will not do any background Message acknowledgment.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizedMessageDispatch' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this flag is set then an larger prefetch limit is used - only
applicable for durable topic subscribers.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='password' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS password used for connections created from this factory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='prefetchPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the <a
href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
policy</a> for consumers created by this connection.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerWindowSize' type='xs:integer'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='redeliveryPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the global default redelivery policy to be used when a message is delivered
but the session is rolled back
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='redeliveryPolicyMap' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the global redelivery policy mapping to be used when a message is delivered
but the session is rolled back
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
      <xs:attribute name='rmIdFromConnectionId' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            uses the connection id as the resource identity for XAResource.isSameRM
ensuring join will only occur on a single connection
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sendAcksAsync' type='xs:boolean'/>
      <xs:attribute name='sendTimeout' type='xs:integer'/>
      <xs:attribute name='sessionTaskRunner' type='xs:string'/>
      <xs:attribute name='statsEnabled' type='xs:boolean'/>
      <xs:attribute name='transactedIndividualAck' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            when true, submit individual transacted acks immediately rather than with transaction completion.
This allows the acks to represent delivery status which can be persisted on rollback
Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transformer' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the transformer used to transform messages before they are sent on
to the JMS bus or when they are received from the bus but before they are
delivered to the JMS client
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transportListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows a listener to be configured on the ConnectionFactory so that when this factory is used
with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
a transport listener.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useAsyncSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Forces the use of <a
href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
adds a massive performance boost; but means that the send() method will
return immediately whether the message has been sent or not which could
lead to message loss.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useBeanNameAsClientIdPrefix' type='xs:boolean'/>
      <xs:attribute name='useCompression' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables the use of compression of the message bodies
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='useRetroactiveConsumer' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not retroactive consumers are enabled. Retroactive
consumers allow non-durable topic subscribers to receive old messages
that were published before the non-durable subscriber started.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='userName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS userName used by connections created by this factory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='warnAboutUnstartedConnectionTimeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables the timeout from a connection creation to when a warning is
generated if the connection is not properly started via
{@link Connection#start()} and a message is received by a consumer. It is
a very common gotcha to forget to <a
href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
the connection</a> so this option makes the default case to create a
warning if the user forgets. To disable the warning just set the value to <
0 (say -1).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='watchTopicAdvisories' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.ConstantPendingMessageLimitStrategy -->
  <xs:element name='constantPendingMessageLimitStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This PendingMessageLimitStrategy is configured to a constant value for all subscriptions.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='limit' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.DefaultDatabaseLocker -->
  <xs:element name='database-locker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an exclusive lock on a database to avoid multiple brokers running
against the same logical database.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='exceptionHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockable' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='exceptionHandler' type='xs:string'/>
      <xs:attribute name='failIfLocked' type='xs:boolean'/>
      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
      <xs:attribute name='lockable' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='queryTimeout' type='xs:integer'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.DB2JDBCAdapter -->
  <xs:element name='db2JDBCAdapter'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.util.DefaultIOExceptionHandler -->
  <xs:element name='defaultIOExceptionHandler'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='ignoreAllErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreNoSpaceErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreSQLExceptions' type='xs:boolean'/>
      <xs:attribute name='noSpaceMessage' type='xs:string'/>
      <xs:attribute name='resumeCheckSleepPeriod' type='xs:long'/>
      <xs:attribute name='sqlExceptionMessage' type='xs:string'/>
      <xs:attribute name='stopStartConnectors' type='xs:boolean'/>
      <xs:attribute name='systemExitOnShutdown' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter -->
  <xs:element name='defaultJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implements all the default JDBC operations that are used by the JDBCPersistenceAdapter. <p/> sub-classing is
encouraged to override the default implementation of methods to account for differences in JDBC Driver
implementations. <p/> The JDBCAdapter inserts and extracts BLOB data using the getBytes()/setBytes() operations. <p/>
The databases/JDBC drivers that use this adapter are:
<ul>
<li></li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.DefaultNetworkBridgeFilterFactory -->
  <xs:element name='defaultNetworkBridgeFilterFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        implement default behavior, filter that will not allow re-send to origin
based on brokerPath and which respects networkTTL
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.DefaultUsageCapacity -->
  <xs:element name='defaultUsageCapacity'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Identify if a limit has been reached
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='limit' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.DemandForwardingBridge -->
  <xs:element name='demandForwardingBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Forwards messages from the local broker to the remote broker based on demand.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='configuration' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:ldapNetworkConnector'/>
              <xs:element ref='tns:multicastNetworkConnector'/>
              <xs:element ref='tns:networkConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkBridgeListener' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='configuration' type='xs:string'/>
      <xs:attribute name='createdByDuplex' type='xs:boolean'/>
      <xs:attribute name='localBroker' type='xs:string'/>
      <xs:attribute name='mbeanObjectName' type='xs:string'/>
      <xs:attribute name='networkBridgeListener' type='xs:string'/>
      <xs:attribute name='remoteBroker' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.view.DestinationDotFilePlugin -->
  <xs:element name='destinationDotFilePlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A <a href="http://www.graphviz.org/">DOT</a> 
file creator plugin which creates a DOT file showing the current topic & queue hierarchies.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='file' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination file name to create the destination diagram
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.filter.DefaultDestinationMapEntry -->
  <xs:element name='destinationEntry'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A default entry in a DestinationMap which holds a single value.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='value' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationEntry'/>
              <xs:element ref='tns:destinationEntry'/>
              <xs:element ref='tns:filteredKahaDB'/>
              <xs:element ref='tns:policyEntry'/>
              <xs:element ref='tns:redeliveryPolicy'/>
              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='value' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.DestinationPathSeparatorBroker -->
  <xs:element name='destinationPathSeparatorPlugin'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='pathSeparator' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.DestinationsPlugin -->
  <xs:element name='destinationsPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A simple plugin that can be used to export/import runtime destinations. It's useful in security constrained
environments where you want to create destinations only through the management APIs and be able to
replicate them to another broker
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='location' type='xs:string'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.DiscardingDeadLetterStrategy -->
  <xs:element name='discarding'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Dead Letter Strategy that discards all messages
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='deadLetterQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='deadLetterQueue' type='xs:string'/>
      <xs:attribute name='enableAudit' type='xs:boolean'/>
      <xs:attribute name='expiration' type='xs:long'/>
      <xs:attribute name='processExpired' type='xs:boolean'/>
      <xs:attribute name='processNonPersistent' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.DiscardingDLQBrokerPlugin -->
  <xs:element name='discardingDLQBrokerPlugin'>
    <xs:complexType>
      <xs:attribute name='dropAll' type='xs:boolean'/>
      <xs:attribute name='dropOnly' type='xs:string'/>
      <xs:attribute name='dropTemporaryQueues' type='xs:boolean'/>
      <xs:attribute name='dropTemporaryTopics' type='xs:boolean'/>
      <xs:attribute name='reportInterval' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingSubscriberMessageStoragePolicy -->
  <xs:element name='fileCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingDurableSubscriberMessageStoragePolicy -->
  <xs:element name='fileDurableSubscriberCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages for durable subscribers
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy -->
  <xs:element name='fileQueueCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.FilteredDestination -->
  <xs:element name='filteredDestination'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents a destination which is filtered using some predicate such as a selector
so that messages are only dispatched to the destination if they match the filter.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The destination to send messages to if they match the filter
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='filter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='destination' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The destination to send messages to if they match the filter
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='filter' type='xs:string'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination property to the given queue name
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='selector' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS selector used to filter messages before forwarding them to this destination
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the destination property to the given topic name
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.kahadb.FilteredKahaDBPersistenceAdapter -->
  <xs:element name='filteredKahaDB'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adapter' type='xs:string'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='perDestination' type='xs:boolean'/>
      <xs:attribute name='persistenceAdapter' type='xs:string'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy -->
  <xs:element name='fixedCountSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
count of last messages.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='maximumSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the maximum number of messages that this destination will hold
around in RAM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy -->
  <xs:element name='fixedSizedSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link SubscriptionRecoveryPolicy} will keep a fixed
amount of memory available in RAM for message history which is evicted in
time order.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='buffer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='buffer' type='xs:string'/>
      <xs:attribute name='maximumSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the maximum amount of RAM in bytes that this buffer can hold in RAM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useSharedBuffer' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.ForcePersistencyModeBroker -->
  <xs:element name='forcePersistencyModeBroker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Plugin which allows to force every incoming message to be PERSISTENT or NON-PERSISTENT. 

Useful, if you have set the broker usage policy to process ONLY persistent or ONLY non-persistent
messages.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='persistenceFlag' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.ForcePersistencyModeBrokerPlugin -->
  <xs:element name='forcePersistencyModeBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Plugin which allows to force every incoming message to be PERSISTENT or
NON-PERSISTENT.

Useful, if you have set the broker usage policy to process ONLY persistent or
ONLY non-persistent messages.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='persistenceFlag' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the persistence mode.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.ForwardingBridge -->
  <xs:element name='forwardingBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Forwards all messages from the local broker to the remote broker.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='localBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkBridgeFailedListener' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='remoteBroker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='clientId' type='xs:string'/>
      <xs:attribute name='destinationFilter' type='xs:string'/>
      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
      <xs:attribute name='localBroker' type='xs:string'/>
      <xs:attribute name='networkBridgeFailedListener' type='xs:string'/>
      <xs:attribute name='prefetchSize' type='xs:integer'/>
      <xs:attribute name='remoteBroker' type='xs:string'/>
      <xs:attribute name='useCompression' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.HsqldbJDBCAdapter -->
  <xs:element name='hsqldb-jdbc-adapter'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor -->
  <xs:element name='imageBasedJDBCAdaptor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Provides JDBCAdapter since that uses
IMAGE datatype to hold binary data.

The databases/JDBC drivers that use this adapter are:
<ul>
<li>Sybase</li>
<li>MS SQL</li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.InboundQueueBridge -->
  <xs:element name='inboundQueueBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Create an Inbound Queue Bridge.  By default this class uses the sname name for
both the inbound and outbound queue.  This behavior can be overridden however
by using the setter methods to configure both the inbound and outboud queue names
separately.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='consumer' type='xs:string'/>
      <xs:attribute name='consumerConnection' type='xs:string'/>
      <xs:attribute name='consumerQueue' type='xs:string'/>
      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
      <xs:attribute name='inboundQueueName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the queue name used for the inbound queue, if the outbound queue
name has not been set, then this method uses the same name to configure
the outbound queue name.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='jmsConnector' type='xs:string'/>
      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
      <xs:attribute name='localQueueName' type='xs:string'/>
      <xs:attribute name='producerConnection' type='xs:string'/>
      <xs:attribute name='producerQueue' type='xs:string'/>
      <xs:attribute name='selector' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.InboundTopicBridge -->
  <xs:element name='inboundTopicBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Create an Inbound Topic Bridge.  By default this class uses the topic name for
both the inbound and outbound topic.  This behavior can be overridden however
by using the setter methods to configure both the inbound and outboud topic names
separately.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerTopic' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerTopic' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='consumer' type='xs:string'/>
      <xs:attribute name='consumerConnection' type='xs:string'/>
      <xs:attribute name='consumerName' type='xs:string'/>
      <xs:attribute name='consumerTopic' type='xs:string'/>
      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
      <xs:attribute name='inboundTopicName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the topic name used for the inbound topic, if the outbound topic
name has not been set, then this method uses the same name to configure
the outbound topic name.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='jmsConnector' type='xs:string'/>
      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
      <xs:attribute name='localTopicName' type='xs:string'/>
      <xs:attribute name='producerConnection' type='xs:string'/>
      <xs:attribute name='producerTopic' type='xs:string'/>
      <xs:attribute name='selector' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy -->
  <xs:element name='individualDeadLetterStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link DeadLetterStrategy} where each destination has its own individual
DLQ using the subject naming hierarchy.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='destinationPerDurableSubscriber' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets whether durable topic subscriptions are to get individual dead letter destinations.
When true, the DLQ is of the form 'topicPrefix.clientId:subscriptionName'
The default is false.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='enableAudit' type='xs:boolean'/>
      <xs:attribute name='expiration' type='xs:long'/>
      <xs:attribute name='processExpired' type='xs:boolean'/>
      <xs:attribute name='processNonPersistent' type='xs:boolean'/>
      <xs:attribute name='queuePrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix to use for all dead letter queues for queue messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='queueSuffix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the suffix to use for all dead letter queues for queue messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='topicPrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix to use for all dead letter queues for topic messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='topicSuffix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the suffix to use for all dead letter queues for topic messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useQueueForQueueMessages' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether a queue or topic should be used for queue messages sent to a
DLQ. The default is to use a Queue
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useQueueForTopicMessages' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether a queue or topic should be used for topic messages sent to a
DLQ. The default is to use a Queue
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.InformixJDBCAdapter -->
  <xs:element name='informixJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        JDBC Adapter for Informix database.
Because Informix database restricts length of composite primary keys, length of 
<i>container name</i> field and <i>subscription id</i> field must be reduced to 150 characters.
Therefore be sure not to use longer names for container name and subscription id than 150 characters.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.JDBCIOExceptionHandler -->
  <xs:element name='jDBCIOExceptionHandler'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='ignoreAllErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreNoSpaceErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreSQLExceptions' type='xs:boolean'/>
      <xs:attribute name='noSpaceMessage' type='xs:string'/>
      <xs:attribute name='resumeCheckSleepPeriod' type='xs:long'/>
      <xs:attribute name='sqlExceptionMessage' type='xs:string'/>
      <xs:attribute name='stopStartConnectors' type='xs:boolean'/>
      <xs:attribute name='systemExitOnShutdown' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.JaasAuthenticationPlugin -->
  <xs:element name='jaasAuthenticationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Provides a JAAS based authentication plugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='configuration' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JAAS configuration domain name used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.JaasCertificateAuthenticationPlugin -->
  <xs:element name='jaasCertificateAuthenticationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Provides a JAAS based SSL certificate authentication plugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='configuration' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JAAS configuration domain name used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.JaasDualAuthenticationPlugin -->
  <xs:element name='jaasDualAuthenticationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Provides a JAAS based authentication plugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='configuration' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JAAS configuration domain name used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='discoverLoginConfig' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the auto-discovery of the login.config file for JAAS to initialize itself. 
This flag is enabled by default such that if the <b>java.security.auth.login.config</b> system property
is not defined then it is set to the location of the <b>login.config</b> file on the classpath.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sslConfiguration' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the JAAS SSL configuration domain
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.JDBCPersistenceAdapter -->
  <xs:element name='jdbcPersistenceAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link PersistenceAdapter} implementation using JDBC for persistence
storage.

This persistence adapter will correctly remember prepared XA transactions,
but it will not keep track of local transaction commits so that operations
performed against the Message store are done as a single uow.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:axionJDBCAdapter'/>
              <xs:element ref='tns:blobJDBCAdapter'/>
              <xs:element ref='tns:bytesJDBCAdapter'/>
              <xs:element ref='tns:db2JDBCAdapter'/>
              <xs:element ref='tns:defaultJDBCAdapter'/>
              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
              <xs:element ref='tns:informixJDBCAdapter'/>
              <xs:element ref='tns:maxdb-jdbc-adapter'/>
              <xs:element ref='tns:mysql-jdbc-adapter'/>
              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
              <xs:element ref='tns:oracleJDBCAdapter'/>
              <xs:element ref='tns:postgresql-jdbc-adapter'/>
              <xs:element ref='tns:streamJDBCAdapter'/>
              <xs:element ref='tns:sybase-jdbc-adapter'/>
              <xs:element ref='tns:transact-jdbc-adapter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='databaseLocker' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the database locker strategy to use to lock the database on startup
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='ds' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockDataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adapter' type='xs:string'/>
      <xs:attribute name='auditRecoveryDepth' type='xs:integer'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='changeAutoCommitAllowed' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Whether the JDBC driver allows to set the auto commit.
Some drivers does not allow changing the auto commit. The default value is true.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='cleanupPeriod' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the number of milliseconds until the database is attempted to be
cleaned up for durable topics
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not tables are created on startup
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dataDirectory' type='xs:string'/>
      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='databaseLocker' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the database locker strategy to use to lock the database on startup
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='ds' type='xs:string'/>
      <xs:attribute name='enableAudit' type='xs:boolean'/>
      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
      <xs:attribute name='lockDataSource' type='xs:string'/>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='maxAuditDepth' type='xs:integer'/>
      <xs:attribute name='maxProducersToAudit' type='xs:integer'/>
      <xs:attribute name='maxRows' type='xs:integer'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='transactionIsolation' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            set the Transaction isolation level to something other that TRANSACTION_READ_UNCOMMITTED
This allowable dirty isolation level may not be achievable in clustered DB environments
so a more restrictive and expensive option may be needed like TRANSACTION_REPEATABLE_READ
see isolation level constants in {@link java.sql.Connection}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useDatabaseLock' type='xs:boolean'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='wireFormat' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.JmsQueueConnector -->
  <xs:element name='jmsQueueConnector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Bridge to other JMS Queue providers
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              One way to configure the local connection - this is called by The
BrokerService when the Connector is embedded
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='inboundMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='inboundQueueBridges' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:inboundQueueBridge'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='localQueueConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='localQueueConnectionFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:connectionFactory'/>
              <xs:element ref='tns:xaConnectionFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundQueueBridges' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:outboundQueueBridge'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundQueueConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundQueueConnectionFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:connectionFactory'/>
              <xs:element ref='tns:xaConnectionFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='reconnectionPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:reconnectionPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            One way to configure the local connection - this is called by The
BrokerService when the Connector is embedded
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='inboundMessageConvertor' type='xs:string'/>
      <xs:attribute name='jndiLocalTemplate' type='xs:string'/>
      <xs:attribute name='jndiOutboundTemplate' type='xs:string'/>
      <xs:attribute name='localClientId' type='xs:string'/>
      <xs:attribute name='localConnectionFactoryName' type='xs:string'/>
      <xs:attribute name='localPassword' type='xs:string'/>
      <xs:attribute name='localQueueConnection' type='xs:string'/>
      <xs:attribute name='localQueueConnectionFactory' type='xs:string'/>
      <xs:attribute name='localUsername' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='outboundClientId' type='xs:string'/>
      <xs:attribute name='outboundMessageConvertor' type='xs:string'/>
      <xs:attribute name='outboundPassword' type='xs:string'/>
      <xs:attribute name='outboundQueueConnection' type='xs:string'/>
      <xs:attribute name='outboundQueueConnectionFactory' type='xs:string'/>
      <xs:attribute name='outboundQueueConnectionFactoryName' type='xs:string'/>
      <xs:attribute name='outboundUsername' type='xs:string'/>
      <xs:attribute name='preferJndiDestinationLookup' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the connector should prefer to first try to find a destination in JNDI before
using JMS semantics to create a Destination.  By default the connector will first use JMS
semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
ordering.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reconnectionPolicy' type='xs:string'/>
      <xs:attribute name='replyToDestinationCacheSize' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.JmsTopicConnector -->
  <xs:element name='jmsTopicConnector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Bridge to other JMS Topic providers
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              One way to configure the local connection - this is called by The
BrokerService when the Connector is embedded
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='inboundMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='inboundTopicBridges' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:inboundTopicBridge'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='localTopicConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='localTopicConnectionFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:connectionFactory'/>
              <xs:element ref='tns:xaConnectionFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundTopicBridges' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:outboundTopicBridge'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundTopicConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='outboundTopicConnectionFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:connectionFactory'/>
              <xs:element ref='tns:xaConnectionFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='reconnectionPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:reconnectionPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            One way to configure the local connection - this is called by The
BrokerService when the Connector is embedded
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='inboundMessageConvertor' type='xs:string'/>
      <xs:attribute name='jndiLocalTemplate' type='xs:string'/>
      <xs:attribute name='jndiOutboundTemplate' type='xs:string'/>
      <xs:attribute name='localClientId' type='xs:string'/>
      <xs:attribute name='localConnectionFactoryName' type='xs:string'/>
      <xs:attribute name='localPassword' type='xs:string'/>
      <xs:attribute name='localTopicConnection' type='xs:string'/>
      <xs:attribute name='localTopicConnectionFactory' type='xs:string'/>
      <xs:attribute name='localUsername' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='outboundClientId' type='xs:string'/>
      <xs:attribute name='outboundMessageConvertor' type='xs:string'/>
      <xs:attribute name='outboundPassword' type='xs:string'/>
      <xs:attribute name='outboundTopicConnection' type='xs:string'/>
      <xs:attribute name='outboundTopicConnectionFactory' type='xs:string'/>
      <xs:attribute name='outboundTopicConnectionFactoryName' type='xs:string'/>
      <xs:attribute name='outboundUsername' type='xs:string'/>
      <xs:attribute name='preferJndiDestinationLookup' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether the connector should prefer to first try to find a destination in JNDI before
using JMS semantics to create a Destination.  By default the connector will first use JMS
semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
ordering.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reconnectionPolicy' type='xs:string'/>
      <xs:attribute name='replyToDestinationCacheSize' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.JobSchedulerUsage -->
  <xs:element name='jobSchedulerUsage'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Used to keep track of how much of something is being used so that a
productive working set usage can be controlled. Main use case is manage
memory usage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultUsageCapacity'/>
              <xs:element ref='tns:usageCapacity'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='limit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
"1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='limiter' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='parent' type='xs:string'/>
      <xs:attribute name='percentUsage' type='xs:integer'/>
      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
manager.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='pollingTime' type='xs:integer'/>
      <xs:attribute name='store' type='xs:string'/>
      <xs:attribute name='usagePortion' type='xs:float'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.journal.JournalPersistenceAdapter -->
  <xs:element name='journalPersistenceAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An implementation of {@link PersistenceAdapter} designed for use with a
{@link Journal} and then check pointing asynchronously on a timeout with some
other long term persistent storage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='longTermPersistence' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='persistenceAdapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkpointInterval' type='xs:long'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='journal' type='xs:string'/>
      <xs:attribute name='longTermPersistence' type='xs:string'/>
      <xs:attribute name='maxCheckpointMessageAddSize' type='xs:integer'/>
      <xs:attribute name='maxCheckpointWorkers' type='xs:integer'/>
      <xs:attribute name='persistenceAdapter' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.journal.JournalPersistenceAdapterFactory -->
  <xs:element name='journalPersistenceAdapterFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Factory class that can create PersistenceAdapter objects.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:axionJDBCAdapter'/>
              <xs:element ref='tns:blobJDBCAdapter'/>
              <xs:element ref='tns:bytesJDBCAdapter'/>
              <xs:element ref='tns:db2JDBCAdapter'/>
              <xs:element ref='tns:defaultJDBCAdapter'/>
              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
              <xs:element ref='tns:informixJDBCAdapter'/>
              <xs:element ref='tns:maxdb-jdbc-adapter'/>
              <xs:element ref='tns:mysql-jdbc-adapter'/>
              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
              <xs:element ref='tns:oracleJDBCAdapter'/>
              <xs:element ref='tns:postgresql-jdbc-adapter'/>
              <xs:element ref='tns:streamJDBCAdapter'/>
              <xs:element ref='tns:sybase-jdbc-adapter'/>
              <xs:element ref='tns:transact-jdbc-adapter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='jdbcAdapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adapter' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkpointInterval' type='xs:long'/>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not tables are created on startup
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dataDirectory' type='xs:string'/>
      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='jdbcAdapter' type='xs:string'/>
      <xs:attribute name='journal' type='xs:string'/>
      <xs:attribute name='journalArchiveDirectory' type='xs:string'/>
      <xs:attribute name='journalLogFileSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the size of the journal log files
When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalLogFiles' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the number of journal log files to use
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalThreadPriority' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the thread priority of the journal thread
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='useDatabaseLock' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not an exclusive database lock should be used to enable
JDBC Master/Slave. Enabled by default.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='useJournal' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the use of the journal. The default is to use the
journal
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='useQuickJournal' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the use of quick journal, which keeps messages in the
journal and just stores a reference to the messages in JDBC. Defaults to
false so that messages actually reside long term in the JDBC database.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.PersistenceAdapterFactoryBean -->
  <xs:element name='journaledJDBC'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Creates a default persistence model using the Journal and JDBC
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:axionJDBCAdapter'/>
              <xs:element ref='tns:blobJDBCAdapter'/>
              <xs:element ref='tns:bytesJDBCAdapter'/>
              <xs:element ref='tns:db2JDBCAdapter'/>
              <xs:element ref='tns:defaultJDBCAdapter'/>
              <xs:element ref='tns:hsqldb-jdbc-adapter'/>
              <xs:element ref='tns:imageBasedJDBCAdaptor'/>
              <xs:element ref='tns:informixJDBCAdapter'/>
              <xs:element ref='tns:maxdb-jdbc-adapter'/>
              <xs:element ref='tns:mysql-jdbc-adapter'/>
              <xs:element ref='tns:oracleBlobJDBCAdapter'/>
              <xs:element ref='tns:oracleJDBCAdapter'/>
              <xs:element ref='tns:postgresql-jdbc-adapter'/>
              <xs:element ref='tns:streamJDBCAdapter'/>
              <xs:element ref='tns:sybase-jdbc-adapter'/>
              <xs:element ref='tns:transact-jdbc-adapter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='jdbcAdapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='journal' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adapter' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkpointInterval' type='xs:long'/>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not tables are created on startup
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dataDirectory' type='xs:string'/>
      <xs:attribute name='dataDirectoryFile' type='xs:string'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='jdbcAdapter' type='xs:string'/>
      <xs:attribute name='journal' type='xs:string'/>
      <xs:attribute name='journalArchiveDirectory' type='xs:string'/>
      <xs:attribute name='journalLogFileSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the size of the journal log files
When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalLogFiles' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the number of journal log files to use
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalThreadPriority' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the thread priority of the journal thread
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='useDatabaseLock' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not an exclusive database lock should be used to enable
JDBC Master/Slave. Enabled by default.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='useJournal' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the use of the journal. The default is to use the
journal
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='useQuickJournal' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the use of quick journal, which keeps messages in the
journal and just stores a reference to the messages in JDBC. Defaults to
false so that messages actually reside long term in the JDBC database.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter -->
  <xs:element name='kahaDB'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An implementation of {@link PersistenceAdapter} designed for use with
KahaDB - Embedded Lightweight Non-Relational Database
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transactionIdTransformer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='archiveCorruptedIndex' type='xs:boolean'/>
      <xs:attribute name='archiveDataLogs' type='xs:boolean'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='checkForCorruptJournalFiles' type='xs:boolean'/>
      <xs:attribute name='checkpointInterval' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the checkpointInterval
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='checksumJournalFiles' type='xs:boolean'/>
      <xs:attribute name='cleanupInterval' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the cleanupInterval
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='concurrentStoreAndDispatchQueues' type='xs:boolean'/>
      <xs:attribute name='concurrentStoreAndDispatchTopics' type='xs:boolean'/>
      <xs:attribute name='databaseLockedWaitDelay' type='xs:integer'/>
      <xs:attribute name='directory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the directory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='directoryArchive' type='xs:string'/>
      <xs:attribute name='enableIndexDiskSyncs' type='xs:boolean'/>
      <xs:attribute name='enableIndexPageCaching' type='xs:boolean'/>
      <xs:attribute name='enableIndexRecoveryFile' type='xs:boolean'/>
      <xs:attribute name='enableIndexWriteAsync' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the enableIndexWriteAsync
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='enableJournalDiskSyncs' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the enableJournalDiskSyncs
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='failoverProducersAuditDepth' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            set the audit window depth for duplicate suppression (should exceed the max transaction
batch)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='forceRecoverIndex' type='xs:boolean'/>
      <xs:attribute name='ignoreMissingJournalfiles' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the ignoreMissingJournalfiles
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='indexCacheSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the indexCacheSize
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='indexDirectory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the directory where KahaDB index files should be written.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='indexLFUEvictionFactor' type='xs:float'/>
      <xs:attribute name='indexWriteBatchSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the indexWriteBatchSize
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalMaxFileLength' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the journalMaxFileLength
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalMaxWriteBatchSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the journalMaxWriteBatchSize
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='maxAsyncJobs' type='xs:integer'/>
      <xs:attribute name='maxFailoverProducersToTrack' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the max number of producers (LRU cache) to track for duplicate sends
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='preallocationScope' type='xs:string'/>
      <xs:attribute name='preallocationStrategy' type='xs:string'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='transactionIdTransformer' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useIndexLFRUEviction' type='xs:boolean'/>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.LDAPAuthorizationMap -->
  <xs:element name='lDAPAuthorizationMap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link AuthorizationMap} which uses LDAP
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='context' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='options' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='queueSearchMatchingFormat' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='topicSearchMatchingFormat' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminAttribute' type='xs:string'/>
      <xs:attribute name='adminBase' type='xs:string'/>
      <xs:attribute name='advisorySearchBase' type='xs:string'/>
      <xs:attribute name='authentication' type='xs:string'/>
      <xs:attribute name='connectionPassword' type='xs:string'/>
      <xs:attribute name='connectionProtocol' type='xs:string'/>
      <xs:attribute name='connectionURL' type='xs:string'/>
      <xs:attribute name='connectionUsername' type='xs:string'/>
      <xs:attribute name='context' type='xs:string'/>
      <xs:attribute name='initialContextFactory' type='xs:string'/>
      <xs:attribute name='options' type='xs:string'/>
      <xs:attribute name='queueSearchMatchingFormat' type='xs:string'/>
      <xs:attribute name='queueSearchSubtreeBool' type='xs:boolean'/>
      <xs:attribute name='readAttribute' type='xs:string'/>
      <xs:attribute name='readBase' type='xs:string'/>
      <xs:attribute name='tempSearchBase' type='xs:string'/>
      <xs:attribute name='topicSearchMatchingFormat' type='xs:string'/>
      <xs:attribute name='topicSearchSubtreeBool' type='xs:boolean'/>
      <xs:attribute name='useAdvisorySearchBase' type='xs:boolean'/>
      <xs:attribute name='writeAttribute' type='xs:string'/>
      <xs:attribute name='writeBase' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy -->
  <xs:element name='lastImageSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link SubscriptionRecoveryPolicy} will only keep the
last message.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.LdapNetworkConnector -->
  <xs:element name='ldapNetworkConnector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        class to create dynamic network connectors listed in an directory server
using the LDAP v3 protocol as defined in RFC 2251, the entries listed in the
directory server must implement the ipHost and ipService objectClasses as
defined in RFC 2307.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='advisoryForFailedForward' type='xs:boolean'/>
      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
      <xs:attribute name='anonymousAuthentication' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets LDAP anonymous authentication access credentials
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='base' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets the base LDAP dn used for lookup operations
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='brokerURL' type='xs:string'/>
      <xs:attribute name='checkDuplicateMessagesOnDuplex' type='xs:boolean'/>
      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
      <xs:attribute name='connectionFilter' type='xs:string'/>
      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
      <xs:attribute name='consumerTTL' type='xs:integer'/>
      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
      <xs:attribute name='destinationFilter' type='xs:string'/>
      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
      <xs:attribute name='duplex' type='xs:boolean'/>
      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
      <xs:attribute name='gcDestinationViews' type='xs:boolean'/>
      <xs:attribute name='gcSweepTime' type='xs:long'/>
      <xs:attribute name='localUri' type='xs:string'/>
      <xs:attribute name='messageTTL' type='xs:integer'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='networkTTL' type='xs:integer'/>
      <xs:attribute name='objectName' type='xs:string'/>
      <xs:attribute name='password' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets the LDAP password for access credentials
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='prefetchSize' type='xs:string'/>
      <xs:attribute name='searchEventListener' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            enables/disable a persistent search to the LDAP server as defined in
draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='searchFilter' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets the LDAP search filter as defined in RFC 2254
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='searchScope' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets the LDAP search scope
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='staticBridge' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
      <xs:attribute name='uri' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            returns the next URI from the configured list
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useBrokerNameAsIdSees' type='xs:boolean'/>
      <xs:attribute name='useCompression' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubs' type='xs:boolean'/>
      <xs:attribute name='user' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            sets the LDAP user for access credentials
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='userName' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.LeaseDatabaseLocker -->
  <xs:element name='lease-database-locker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an exclusive lease on a database to avoid multiple brokers running
against the same logical database.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockable' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='failIfLocked' type='xs:boolean'/>
      <xs:attribute name='handleStartException' type='xs:boolean'/>
      <xs:attribute name='leaseHolderId' type='xs:string'/>
      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
      <xs:attribute name='lockable' type='xs:string'/>
      <xs:attribute name='maxAllowableDiffFromDBTime' type='xs:integer'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='queryTimeout' type='xs:integer'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.util.LeaseLockerIOExceptionHandler -->
  <xs:element name='leaseLockerIOExceptionHandler'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='ignoreAllErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreNoSpaceErrors' type='xs:boolean'/>
      <xs:attribute name='ignoreSQLExceptions' type='xs:boolean'/>
      <xs:attribute name='noSpaceMessage' type='xs:string'/>
      <xs:attribute name='resumeCheckSleepPeriod' type='xs:long'/>
      <xs:attribute name='sqlExceptionMessage' type='xs:string'/>
      <xs:attribute name='stopStartConnectors' type='xs:boolean'/>
      <xs:attribute name='systemExitOnShutdown' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.leveldb.LevelDBPersistenceAdapter -->
  <xs:element name='levelDB'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
LevelDB - Embedded Lightweight Non-Relational Database
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transactionIdTransformer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='asyncBufferSize' type='xs:integer'/>
      <xs:attribute name='autoCompactionRatio' type='xs:integer'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='failoverProducersAuditDepth' type='xs:integer'/>
      <xs:attribute name='flushDelay' type='xs:integer'/>
      <xs:attribute name='indexBlockRestartInterval' type='xs:integer'/>
      <xs:attribute name='indexBlockSize' type='xs:integer'/>
      <xs:attribute name='indexCacheSize' type='xs:long'/>
      <xs:attribute name='indexCompression' type='xs:string'/>
      <xs:attribute name='indexFactory' type='xs:string'/>
      <xs:attribute name='indexMaxOpenFiles' type='xs:integer'/>
      <xs:attribute name='indexWriteBufferSize' type='xs:integer'/>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='logCompression' type='xs:string'/>
      <xs:attribute name='logDirectory' type='xs:string'/>
      <xs:attribute name='logSize' type='xs:long'/>
      <xs:attribute name='maxFailoverProducersToTrack' type='xs:integer'/>
      <xs:attribute name='monitorStats' type='xs:boolean'/>
      <xs:attribute name='paranoidChecks' type='xs:boolean'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='sync' type='xs:boolean'/>
      <xs:attribute name='transactionIdTransformer' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='verifyChecksums' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.LoggingBrokerPlugin -->
  <xs:element name='loggingBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A simple Broker intercepter which allows you to enable/disable logging.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='logAll' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger all Events that go through the Plugin
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logConnectionEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are related to connections
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logConsumerEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are related to Consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logInternalEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are normally internal to the broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logProducerEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are related to Producers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logSessionEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are related to sessions
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='logTransactionEvents' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Logger Events that are related to transaction processing
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='perDestinationLogger' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.kahadb.MultiKahaDBPersistenceAdapter -->
  <xs:element name='mKahaDB'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An implementation of {@link org.apache.activemq.store.PersistenceAdapter}  that supports
distribution of destinations across multiple kahaDB persistence adapters
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='filteredPersistenceAdapters' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the  FilteredKahaDBPersistenceAdapter entries
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transactionStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='journalMaxFileLength' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the max file length of the transaction journal
When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='journalWriteBatchSize' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the max write batch size of  the transaction journal
When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can
be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='transactionStore' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.jmx.ManagementContext -->
  <xs:element name='managementContext'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An abstraction over JMX mbean registration
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='MBeanServer' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the MBeanServer
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='environment' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='server' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='MBeanServer' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the MBeanServer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='allowRemoteAddressInMBeanNames' type='xs:boolean'/>
      <xs:attribute name='brokerName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the broker name this context is used by, may be <tt>null</tt>
if the broker name was not set.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectorHost' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the connectorHost
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectorPath' type='xs:string'/>
      <xs:attribute name='connectorPort' type='xs:string'/>
      <xs:attribute name='createConnector' type='xs:string'/>
      <xs:attribute name='createMBeanServer' type='xs:boolean'/>
      <xs:attribute name='environment' type='xs:string'/>
      <xs:attribute name='findTigerMbeanServer' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables/disables the searching for the Java 5 platform MBeanServer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='jmxDomainName' type='xs:string'/>
      <xs:attribute name='rmiServerPort' type='xs:string'/>
      <xs:attribute name='server' type='xs:string'/>
      <xs:attribute name='suppressMBean' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allow selective MBeans registration to be suppressed. Any Mbean ObjectName that matches any
of the supplied attribute values will not be registered with the MBeanServer.
eg: "endpoint=dynamicProducer,endpoint=Consumer" will suppress the registration of *all* dynamic producer and consumer mbeans.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useMBeanServer' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.MaxDBJDBCAdapter -->
  <xs:element name='maxdb-jdbc-adapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        JDBC Adapter for the MaxDB database.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.memory.MemoryPersistenceAdapter -->
  <xs:element name='memoryPersistenceAdapter'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='createTransactionStore' type='xs:boolean'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.MemoryUsage -->
  <xs:element name='memoryUsage'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Used to keep track of how much of something is being used so that a
productive working set usage can be controlled. Main use case is manage
memory usage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultUsageCapacity'/>
              <xs:element ref='tns:usageCapacity'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='limit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
"1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='limiter' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='parent' type='xs:string'/>
      <xs:attribute name='percentOfJvmHeap' type='xs:integer'/>
      <xs:attribute name='percentUsage' type='xs:integer'/>
      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
manager.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='pollingTime' type='xs:integer'/>
      <xs:attribute name='portion' type='xs:float'/>
      <xs:attribute name='usage' type='xs:long'/>
      <xs:attribute name='usagePortion' type='xs:float'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory -->
  <xs:element name='messageGroupHashBucketFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A factory to create instances of {@link SimpleMessageGroupMap} when
implementing the <a
href="http://activemq.apache.org/message-groups.html">Message
Groups</a> functionality.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='bucketCount' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the number of hash buckets to use for the message group
functionality. This is only applicable to using message groups to
parallelize processing of a queue while preserving order across an
individual JMSXGroupID header value. This value sets the number of hash
buckets that will be used (i.e. the maximum possible concurrency).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='cacheSize' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.MirroredQueue -->
  <xs:element name='mirroredQueue'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Creates <a href="http://activemq.org/site/mirrored-queues.html">Mirrored
Queue</a> using a prefix and postfix to define the topic name on which to mirror the queue to.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='copyMessage' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether a copy of the message will be sent to each destination.
Defaults to true so that the forward destination is set as the
destination of the message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='postfix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets any postix used to identify the queue consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='prefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix wildcard used to identify the queue consumers for a given
topic
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.MulticastNetworkConnector -->
  <xs:element name='multicastNetworkConnector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A network connector which uses some kind of multicast-like transport that
communicates with potentially many remote brokers over a single logical
{@link Transport} instance such as when using multicast.

This implementation does not depend on multicast at all; any other group
based transport could be used.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='bridge' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:compositeDemandForwardingBridge'/>
              <xs:element ref='tns:demandForwardingBridge'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='localTransport' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='remoteTransport' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the remote transport implementation
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='advisoryForFailedForward' type='xs:boolean'/>
      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
      <xs:attribute name='bridge' type='xs:string'/>
      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='brokerURL' type='xs:string'/>
      <xs:attribute name='checkDuplicateMessagesOnDuplex' type='xs:boolean'/>
      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
      <xs:attribute name='connectionFilter' type='xs:string'/>
      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
      <xs:attribute name='consumerTTL' type='xs:integer'/>
      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
      <xs:attribute name='destinationFilter' type='xs:string'/>
      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
      <xs:attribute name='duplex' type='xs:boolean'/>
      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
      <xs:attribute name='gcDestinationViews' type='xs:boolean'/>
      <xs:attribute name='gcSweepTime' type='xs:long'/>
      <xs:attribute name='localTransport' type='xs:string'/>
      <xs:attribute name='localUri' type='xs:string'/>
      <xs:attribute name='messageTTL' type='xs:integer'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='networkTTL' type='xs:integer'/>
      <xs:attribute name='objectName' type='xs:string'/>
      <xs:attribute name='password' type='xs:string'/>
      <xs:attribute name='prefetchSize' type='xs:string'/>
      <xs:attribute name='remoteTransport' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the remote transport implementation
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='remoteURI' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the remote transport URI to some group transport like
<code>multicast://address:port</code>
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='staticBridge' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
      <xs:attribute name='useBrokerNameAsIdSees' type='xs:boolean'/>
      <xs:attribute name='useCompression' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubs' type='xs:boolean'/>
      <xs:attribute name='userName' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.MulticastTraceBrokerPlugin -->
  <xs:element name='multicastTraceBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Broker interceptor which allows you to trace all operations to a Multicast
socket.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='address' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wireFormatFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='address' type='xs:string'/>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='broadcast' type='xs:boolean'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='maxTraceDatagramSize' type='xs:integer'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='timeToLive' type='xs:integer'/>
      <xs:attribute name='wireFormat' type='xs:string'/>
      <xs:attribute name='wireFormatFactory' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.MySqlJDBCAdapter -->
  <xs:element name='mysql-jdbc-adapter'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='engineType' type='xs:string'/>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='typeStatement' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.DiscoveryNetworkConnector -->
  <xs:element name='networkConnector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A network connector which uses a discovery agent to detect the remote brokers
available and setup a connection to each available remote broker
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='connectionFilter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='discoveryAgent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='durableDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='dynamicallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='excludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='staticallyIncludedDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='advisoryForFailedForward' type='xs:boolean'/>
      <xs:attribute name='alwaysSyncSend' type='xs:boolean'/>
      <xs:attribute name='bridgeTempDestinations' type='xs:boolean'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='brokerURL' type='xs:string'/>
      <xs:attribute name='checkDuplicateMessagesOnDuplex' type='xs:boolean'/>
      <xs:attribute name='conduitSubscriptions' type='xs:boolean'/>
      <xs:attribute name='connectionFilter' type='xs:string'/>
      <xs:attribute name='consumerPriorityBase' type='xs:integer'/>
      <xs:attribute name='consumerTTL' type='xs:integer'/>
      <xs:attribute name='decreaseNetworkConsumerPriority' type='xs:boolean'/>
      <xs:attribute name='destinationFilter' type='xs:string'/>
      <xs:attribute name='discoveryAgent' type='xs:string'/>
      <xs:attribute name='discoveryURI' type='xs:string'/>
      <xs:attribute name='dispatchAsync' type='xs:boolean'/>
      <xs:attribute name='duplex' type='xs:boolean'/>
      <xs:attribute name='dynamicOnly' type='xs:boolean'/>
      <xs:attribute name='gcDestinationViews' type='xs:boolean'/>
      <xs:attribute name='gcSweepTime' type='xs:long'/>
      <xs:attribute name='localUri' type='xs:string'/>
      <xs:attribute name='messageTTL' type='xs:integer'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='networkTTL' type='xs:integer'/>
      <xs:attribute name='objectName' type='xs:string'/>
      <xs:attribute name='password' type='xs:string'/>
      <xs:attribute name='prefetchSize' type='xs:string'/>
      <xs:attribute name='staticBridge' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateQueueSubscriptions' type='xs:boolean'/>
      <xs:attribute name='suppressDuplicateTopicSubscriptions' type='xs:boolean'/>
      <xs:attribute name='uri' type='xs:string'/>
      <xs:attribute name='useBrokerNameAsIdSees' type='xs:boolean'/>
      <xs:attribute name='useCompression' type='xs:boolean'/>
      <xs:attribute name='useVirtualDestSubs' type='xs:boolean'/>
      <xs:attribute name='userName' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy -->
  <xs:element name='noSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This SubscriptionRecoveryPolicy disable recovery of messages.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy -->
  <xs:element name='oldestMessageEvictionStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An eviction strategy which evicts the oldest message first (which is the
default).
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the high water mark on which we will eagerly evict expired messages from RAM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.OldestMessageWithLowestPriorityEvictionStrategy -->
  <xs:element name='oldestMessageWithLowestPriorityEvictionStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An eviction strategy which evicts the oldest message with the lowest priority first.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the high water mark on which we will eagerly evict expired messages from RAM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.OracleBlobJDBCAdapter -->
  <xs:element name='oracleBlobJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implements all the default JDBC operations that are used
by the JDBCPersistenceAdapter.
<p/>
Subclassing is encouraged to override the default
implementation of methods to account for differences
in JDBC Driver implementations.
<p/>
The JDBCAdapter inserts and extracts BLOB data using the
getBytes()/setBytes() operations.
<p/>
The databases/JDBC drivers that use this adapter are:
<ul>
<li></li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter -->
  <xs:element name='oracleJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implements all the default JDBC operations that are used
by the JDBCPersistenceAdapter.
<p/>
Subclassing is encouraged to override the default
implementation of methods to account for differences
in JDBC Driver implementations.
<p/>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.OutboundQueueBridge -->
  <xs:element name='outboundQueueBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Create an Outbound Queue Bridge.  By default the bridge uses the same
name for both the inbound and outbound queues, however this can be altered
by using the public setter methods to configure both inbound and outbound
queue names.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='consumer' type='xs:string'/>
      <xs:attribute name='consumerConnection' type='xs:string'/>
      <xs:attribute name='consumerQueue' type='xs:string'/>
      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
      <xs:attribute name='jmsConnector' type='xs:string'/>
      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
      <xs:attribute name='localQueueName' type='xs:string'/>
      <xs:attribute name='outboundQueueName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of the outbound queue name.  If the inbound queue name
has not been set already then this method uses the provided queue name
to set the inbound topic name as well.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerConnection' type='xs:string'/>
      <xs:attribute name='producerQueue' type='xs:string'/>
      <xs:attribute name='selector' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.OutboundTopicBridge -->
  <xs:element name='outboundTopicBridge'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Create an Outbound Topic Bridge.  By default the bridge uses the same
name for both the inbound and outbound topics, however this can be altered
by using the public setter methods to configure both inbound and outbound
topic names.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='consumer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='consumerTopic' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsConnector' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jmsQueueConnector'/>
              <xs:element ref='tns:jmsTopicConnector'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='jmsMessageConvertor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:simpleJmsMessageConvertor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerConnection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='producerTopic' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='consumer' type='xs:string'/>
      <xs:attribute name='consumerConnection' type='xs:string'/>
      <xs:attribute name='consumerName' type='xs:string'/>
      <xs:attribute name='consumerTopic' type='xs:string'/>
      <xs:attribute name='doHandleReplyTo' type='xs:boolean'/>
      <xs:attribute name='jmsConnector' type='xs:string'/>
      <xs:attribute name='jmsMessageConvertor' type='xs:string'/>
      <xs:attribute name='localTopicName' type='xs:string'/>
      <xs:attribute name='outboundTopicName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the name of the outbound topic name.  If the inbound topic name
has not been set already then this method uses the provided topic name
to set the inbound topic name as well.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerConnection' type='xs:string'/>
      <xs:attribute name='producerTopic' type='xs:string'/>
      <xs:attribute name='selector' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.kahadb.plist.PListStoreImpl -->
  <xs:element name='pListStoreImpl'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='cleanupInterval' type='xs:long'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='enableIndexWriteAsync' type='xs:boolean'/>
      <xs:attribute name='failIfDatabaseIsLocked' type='xs:boolean'/>
      <xs:attribute name='indexCacheSize' type='xs:integer'/>
      <xs:attribute name='indexEnablePageCaching' type='xs:boolean'/>
      <xs:attribute name='indexPageSize' type='xs:integer'/>
      <xs:attribute name='indexWriteBatchSize' type='xs:integer'/>
      <xs:attribute name='journalMaxFileLength' type='xs:integer'/>
      <xs:attribute name='journalMaxWriteBatchSize' type='xs:integer'/>
      <xs:attribute name='lazyInit' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.partition.PartitionBrokerPlugin -->
  <xs:element name='partitionBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A BrokerPlugin which partitions client connections over a cluster of brokers.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='config' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='config' type='xs:string'/>
      <xs:attribute name='configAsJson' type='xs:string'/>
      <xs:attribute name='minTransferCount' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.PolicyEntry -->
  <xs:element name='policyEntry'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an entry in a {@link PolicyMap} for assigning policies to a
specific destination or a hierarchical wildcard area of destinations.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='deadLetterStrategy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to determine which dead letter queue destination
should be used
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:discarding'/>
              <xs:element ref='tns:individualDeadLetterStrategy'/>
              <xs:element ref='tns:sharedDeadLetterStrategy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='dispatchPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:priorityDispatchPolicy'/>
              <xs:element ref='tns:priorityNetworkDispatchPolicy'/>
              <xs:element ref='tns:roundRobinDispatchPolicy'/>
              <xs:element ref='tns:simpleDispatchPolicy'/>
              <xs:element ref='tns:strictOrderDispatchPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageEvictionStrategy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the eviction strategy used to decide which message to evict when the
slow consumer needs to discard messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:oldestMessageEvictionStrategy'/>
              <xs:element ref='tns:oldestMessageWithLowestPriorityEvictionStrategy'/>
              <xs:element ref='tns:uniquePropertyMessageEvictionStrategy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageGroupMapFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the factory used to create new instances of {MessageGroupMap} used
to implement the <a
href="http://activemq.apache.org/message-groups.html">Message Groups</a>
functionality.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:cachedMessageGroupMapFactory'/>
              <xs:element ref='tns:messageGroupHashBucketFactory'/>
              <xs:element ref='tns:simpleMessageGroupMapFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='networkBridgeFilterFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:conditionalNetworkBridgeFilterFactory'/>
              <xs:element ref='tns:defaultNetworkBridgeFilterFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='pendingDurableSubscriberPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:fileDurableSubscriberCursor'/>
              <xs:element ref='tns:storeDurableSubscriberCursor'/>
              <xs:element ref='tns:vmDurableCursor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='pendingMessageLimitStrategy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the strategy to calculate the maximum number of messages that are
allowed to be pending on consumers (in addition to their prefetch sizes).
Once the limit is reached, non-durable topics can then start discarding
old messages. This allows us to keep dispatching messages to slow
consumers while not blocking fast consumers and discarding the messages
oldest first.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:constantPendingMessageLimitStrategy'/>
              <xs:element ref='tns:prefetchRatePendingMessageLimitStrategy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='pendingQueuePolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:fileQueueCursor'/>
              <xs:element ref='tns:storeCursor'/>
              <xs:element ref='tns:vmQueueCursor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='pendingSubscriberPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:fileCursor'/>
              <xs:element ref='tns:vmCursor'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='slowConsumerStrategy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:abortSlowAckConsumerStrategy'/>
              <xs:element ref='tns:abortSlowConsumerStrategy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='subscriptionRecoveryPolicy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:fixedCountSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:fixedSizedSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:lastImageSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:noSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:queryBasedSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:retainedMessageSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:timedSubscriptionRecoveryPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='advisoryForConsumed' type='xs:boolean'/>
      <xs:attribute name='advisoryForDelivery' type='xs:boolean'/>
      <xs:attribute name='advisoryForDiscardingMessages' type='xs:boolean'/>
      <xs:attribute name='advisoryForFastProducers' type='xs:boolean'/>
      <xs:attribute name='advisoryForSlowConsumers' type='xs:boolean'/>
      <xs:attribute name='advisoryWhenFull' type='xs:boolean'/>
      <xs:attribute name='allConsumersExclusiveByDefault' type='xs:boolean'/>
      <xs:attribute name='alwaysRetroactive' type='xs:boolean'/>
      <xs:attribute name='blockedProducerWarningInterval' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set's the interval at which warnings about producers being blocked by
resource usage will be triggered. Values of 0 or less will disable
warnings
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='consumersBeforeDispatchStarts' type='xs:integer'/>
      <xs:attribute name='cursorMemoryHighWaterMark' type='xs:integer'/>
      <xs:attribute name='deadLetterStrategy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to determine which dead letter queue destination
should be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='dispatchPolicy' type='xs:string'/>
      <xs:attribute name='doOptimzeMessageStorage' type='xs:boolean'/>
      <xs:attribute name='durableTopicPrefetch' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the durableTopicPrefetch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='enableAudit' type='xs:boolean'/>
      <xs:attribute name='expireMessagesPeriod' type='xs:long'/>
      <xs:attribute name='gcInactiveDestinations' type='xs:boolean'/>
      <xs:attribute name='gcWithNetworkConsumers' type='xs:boolean'/>
      <xs:attribute name='inactiveTimeoutBeforeGC' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the amount of time a destination is inactive before it is marked for GC
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='inactiveTimoutBeforeGC' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the amount of time a destination is inactive before it is marked for GC
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='includeBodyForAdvisory' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns true if the original message body should be included when applicable
for advisory messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='lazyDispatch' type='xs:boolean'/>
      <xs:attribute name='maxAuditDepth' type='xs:integer'/>
      <xs:attribute name='maxBrowsePageSize' type='xs:integer'/>
      <xs:attribute name='maxDestinations' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the maximum number of destinations that can be created
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxExpirePageSize' type='xs:integer'/>
      <xs:attribute name='maxPageSize' type='xs:integer'/>
      <xs:attribute name='maxProducersToAudit' type='xs:integer'/>
      <xs:attribute name='maxQueueAuditDepth' type='xs:integer'/>
      <xs:attribute name='memoryLimit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageEvictionStrategy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the eviction strategy used to decide which message to evict when the
slow consumer needs to discard messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageGroupMapFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the factory used to create new instances of {MessageGroupMap} used
to implement the <a
href="http://activemq.apache.org/message-groups.html">Message Groups</a>
functionality.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageGroupMapFactoryType' type='xs:string'/>
      <xs:attribute name='minimumMessageSize' type='xs:long'/>
      <xs:attribute name='networkBridgeFilterFactory' type='xs:string'/>
      <xs:attribute name='optimizeMessageStoreInFlightLimit' type='xs:integer'/>
      <xs:attribute name='optimizedDispatch' type='xs:boolean'/>
      <xs:attribute name='pendingDurableSubscriberPolicy' type='xs:string'/>
      <xs:attribute name='pendingMessageLimitStrategy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the strategy to calculate the maximum number of messages that are
allowed to be pending on consumers (in addition to their prefetch sizes).
Once the limit is reached, non-durable topics can then start discarding
old messages. This allows us to keep dispatching messages to slow
consumers while not blocking fast consumers and discarding the messages
oldest first.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='pendingQueuePolicy' type='xs:string'/>
      <xs:attribute name='pendingSubscriberPolicy' type='xs:string'/>
      <xs:attribute name='persistJMSRedelivered' type='xs:boolean'/>
      <xs:attribute name='prioritizedMessages' type='xs:boolean'/>
      <xs:attribute name='producerFlowControl' type='xs:boolean'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='queueBrowserPrefetch' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the queueBrowserPrefetch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='queuePrefetch' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the queuePrefetch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='reduceMemoryFootprint' type='xs:boolean'/>
      <xs:attribute name='sendAdvisoryIfNoConsumers' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sends an advisory message if a non-persistent message is sent and there
are no active consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='slowConsumerStrategy' type='xs:string'/>
      <xs:attribute name='storeUsageHighWaterMark' type='xs:integer'/>
      <xs:attribute name='strictOrderDispatch' type='xs:boolean'/>
      <xs:attribute name='subscriptionRecoveryPolicy' type='xs:string'/>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='timeBeforeDispatchStarts' type='xs:integer'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='topicPrefetch' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the topicPrefetch
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useCache' type='xs:boolean'/>
      <xs:attribute name='useConsumerPriority' type='xs:boolean'/>
      <xs:attribute name='usePrefetchExtension' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.PolicyMap -->
  <xs:element name='policyMap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents a destination based configuration of policies so that individual
destinations or wildcard hierarchies of destinations can be configured using
different policies.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:policyEntry'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='entries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A helper method to allow the destination map to be populated from a
dependency injection framework such as Spring
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='policyEntries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the individual entries on the policy map
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='defaultEntry' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.pool.PooledConnectionFactoryBean -->
  <xs:element name='pooledConnectionFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Simple factory bean used to create a jencks connection pool.
Depending on the properties set, it will create a simple pool,
a transaction aware connection pool, or a jca aware connection pool.

<pre class="code">
<bean id="pooledConnectionFactory" class="javax.script.ScriptEngineFactory.PooledConnectionFactoryFactoryBean">
  <property name="connectionFactory" ref="connectionFactory" />
  <property name="transactionManager" ref="transactionManager" />
  <property name="resourceName" value="ResourceName" />
</bean>
</pre>

The <code>resourceName</code> property should be used along with the {@link org.apache.activemq.jms.pool.GenericResourceManager} and have
the same value than its <code>resourceName</code> property. This will make sure the transaction manager
maps correctly the connection factory to the recovery process.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='connectionFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:connectionFactory'/>
              <xs:element ref='tns:xaConnectionFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transactionManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='connectionFactory' type='xs:string'/>
      <xs:attribute name='maxConnections' type='xs:integer'/>
      <xs:attribute name='maximumActive' type='xs:integer'/>
      <xs:attribute name='resourceName' type='xs:string'/>
      <xs:attribute name='transactionManager' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.PostgresqlJDBCAdapter -->
  <xs:element name='postgresql-jdbc-adapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implements all the default JDBC operations that are used
by the JDBCPersistenceAdapter.
<p/>
Subclassing is encouraged to override the default
implementation of methods to account for differences
in JDBC Driver implementations.
<p/>
The JDBCAdapter inserts and extracts BLOB data using the
getBytes()/setBytes() operations.
<p/>
The databases/JDBC drivers that use this adapter are:
<ul>
<li></li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='acksPkName' type='xs:string'/>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.ActiveMQPrefetchPolicy -->
  <xs:element name='prefetchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Defines the prefetch message policies for different types of consumers
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='all' type='xs:integer'/>
      <xs:attribute name='durableTopicPrefetch' type='xs:integer'/>
      <xs:attribute name='maximumPendingMessageLimit' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets how many messages a broker will keep around, above the prefetch
limit, for non-durable topics before starting to discard older messages.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizeDurableTopicPrefetch' type='xs:integer'/>
      <xs:attribute name='queueBrowserPrefetch' type='xs:integer'/>
      <xs:attribute name='queuePrefetch' type='xs:integer'/>
      <xs:attribute name='topicPrefetch' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.PrefetchRatePendingMessageLimitStrategy -->
  <xs:element name='prefetchRatePendingMessageLimitStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This PendingMessageLimitStrategy sets the maximum pending message limit value to be
a multiplier of the prefetch limit of the subscription.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='multiplier' type='xs:double'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the multiplier of the prefetch size which will be used to define the maximum number of pending
messages for non-durable topics before messages are discarded.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.PriorityDispatchPolicy -->
  <xs:element name='priorityDispatchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Priority dispatch policy that sends a message to every subscription that
matches the message in consumer priority order.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.PriorityNetworkDispatchPolicy -->
  <xs:element name='priorityNetworkDispatchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        dispatch policy that ignores lower priority duplicate network consumers,
used in conjunction with network bridge suppresDuplicateTopicSubscriptions
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.proxy.ProxyConnector -->
  <xs:element name='proxyConnector'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='server' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='bind' type='xs:string'/>
      <xs:attribute name='localUri' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='proxyToLocalBroker' type='xs:boolean'/>
      <xs:attribute name='remote' type='xs:string'/>
      <xs:attribute name='server' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.PublishedAddressPolicy -->
  <xs:element name='publishedAddressPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Policy object that controls how a TransportConnector publishes the connector's
address to the outside world.  By default the connector will publish itself
using the resolved host name of the bound server socket.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='portMapping' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='clusterClientUriQuery' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the URI query that's configured on the published URI that's sent to client's
when the cluster info is updated.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='portMapping' type='xs:string'/>
      <xs:attribute name='publishedHostStrategy' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.QueryBasedSubscriptionRecoveryPolicy -->
  <xs:element name='queryBasedSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link SubscriptionRecoveryPolicy} will perform a user
specific query mechanism to load any messages they may have missed.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='query' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the query strategy to load initial messages
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='query' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the query strategy to load initial messages
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.command.ActiveMQQueue -->
  <xs:element name='queue'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ActiveMQ Queue
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='physicalName' type='xs:string'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.QueueDispatchSelector -->
  <xs:element name='queueDispatchSelector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Queue dispatch policy that determines if a message can be sent to a subscription
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='exclusiveConsumer' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='exclusiveConsumer' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.ReconnectionPolicy -->
  <xs:element name='reconnectionPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A policy object that defines how a {@link JmsConnector} deals with
reconnection of the local and foreign connections.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='backOffMultiplier' type='xs:double'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the multiplier used to grow the delay between connection attempts from the initial
time to the max set time.  By default this value is set to 2.0.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='initialReconnectDelay' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the initial delay value used before a reconnection attempt is made.  If the
use exponential back-off value is set to false then this will be the fixed time
between connection attempts.  By default this value is set to one second.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxInitialConnectAttempts' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the maximum number of times that the {@link JmsConnector} will try
to connect on startup to before it marks itself as failed and does not
try any further connections.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxReconnectAttempts' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the number of time that {@link JmsConnector} will attempt to connect
or reconnect before giving up.  By default the policy sets this value to
a negative value meaning try forever.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxSendRetries' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the maximum number of a times a Message send should be retried before
a JMSExeception is thrown indicating that the operation failed.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maximumReconnectDelay' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the maximum delay that is inserted between each attempt to connect
before another attempt is made.  The default setting for this value is
30 seconds.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sendRetyDelay' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the amount of time the DestionationBridge will wait between attempts
to forward a message.  The default policy limits the minimum time between
send attempt to one second.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useExponentialBackOff' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets whether the policy uses the set back-off multiplier to grow the time between
connection attempts.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.RedeliveryPlugin -->
  <xs:element name='redeliveryPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Replace regular DLQ handling with redelivery via a resend to the original destination
after a delay
A destination matching RedeliveryPolicy controls the quantity and delay for re-sends
If there is no matching policy or an existing policy limit is exceeded by default
regular DLQ processing resumes. This is controlled via sendToDlqIfMaxRetriesExceeded
and fallbackToDeadLetter
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='fallbackToDeadLetter' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            What to do if there is no matching redelivery policy for a destination.
when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
when false, there is no action
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='redeliveryPolicyMap' type='xs:string'/>
      <xs:attribute name='sendToDlqIfMaxRetriesExceeded' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            What to do if the maxretries on a matching redelivery policy is exceeded.
when true, the region broker DLQ processing will be used via sendToDeadLetterQueue
when false, there is no action
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.RedeliveryPolicy -->
  <xs:element name='redeliveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Configuration options for a messageConsumer used to control how messages are re-delivered when they
are rolled back.
May be used server side on a per destination basis via the Broker RedeliveryPlugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='backOffMultiplier' type='xs:double'/>
      <xs:attribute name='collisionAvoidancePercent' type='xs:short'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='initialRedeliveryDelay' type='xs:long'/>
      <xs:attribute name='maximumRedeliveries' type='xs:integer'/>
      <xs:attribute name='maximumRedeliveryDelay' type='xs:long'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='redeliveryDelay' type='xs:long'/>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useCollisionAvoidance' type='xs:boolean'/>
      <xs:attribute name='useExponentialBackOff' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.RedeliveryPolicyMap -->
  <xs:element name='redeliveryPolicyMap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents a destination based configuration of policies so that individual
destinations or wildcard hierarchies of destinations can be configured using
different policies.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='defaultEntry' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='entries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A helper method to allow the destination map to be populated from a
dependency injection framework such as Spring
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicyEntries' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the individual entries on the redeliveryPolicyMap
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='defaultEntry' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.leveldb.ReplicatedLevelDBPersistenceAdapter -->
  <xs:element name='replicatedLevelDB'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An implementation of {@link org.apache.activemq.store.PersistenceAdapter} designed for use with
LevelDB - Embedded Lightweight Non-Relational Database
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='locker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:database-locker'/>
              <xs:element ref='tns:lease-database-locker'/>
              <xs:element ref='tns:shared-file-locker'/>
              <xs:element ref='tns:transact-database-locker'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='scheduledThreadPoolExecutor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='usageManager' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='asyncBufferSize' type='xs:integer'/>
      <xs:attribute name='bind' type='xs:string'/>
      <xs:attribute name='brokerName' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'/>
      <xs:attribute name='connectUrl' type='xs:string'/>
      <xs:attribute name='container' type='xs:string'/>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='failoverProducersAuditDepth' type='xs:integer'/>
      <xs:attribute name='flushDelay' type='xs:integer'/>
      <xs:attribute name='hostname' type='xs:string'/>
      <xs:attribute name='indexBlockRestartInterval' type='xs:integer'/>
      <xs:attribute name='indexBlockSize' type='xs:integer'/>
      <xs:attribute name='indexCacheSize' type='xs:long'/>
      <xs:attribute name='indexCompression' type='xs:string'/>
      <xs:attribute name='indexFactory' type='xs:string'/>
      <xs:attribute name='indexMaxOpenFiles' type='xs:integer'/>
      <xs:attribute name='indexWriteBufferSize' type='xs:integer'/>
      <xs:attribute name='lockKeepAlivePeriod' type='xs:long'/>
      <xs:attribute name='locker' type='xs:string'/>
      <xs:attribute name='logCompression' type='xs:string'/>
      <xs:attribute name='logSize' type='xs:long'/>
      <xs:attribute name='maxFailoverProducersToTrack' type='xs:integer'/>
      <xs:attribute name='monitorStats' type='xs:boolean'/>
      <xs:attribute name='paranoidChecks' type='xs:boolean'/>
      <xs:attribute name='replicas' type='xs:integer'/>
      <xs:attribute name='scheduledThreadPoolExecutor' type='xs:string'/>
      <xs:attribute name='securityToken' type='xs:string'/>
      <xs:attribute name='sync' type='xs:string'/>
      <xs:attribute name='usageManager' type='xs:string'/>
      <xs:attribute name='useLock' type='xs:boolean'/>
      <xs:attribute name='verifyChecksums' type='xs:boolean'/>
      <xs:attribute name='weight' type='xs:integer'/>
      <xs:attribute name='zkAddress' type='xs:string'/>
      <xs:attribute name='zkPassword' type='xs:string'/>
      <xs:attribute name='zkPath' type='xs:string'/>
      <xs:attribute name='zkSessionTimeout' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy -->
  <xs:element name='retainedMessageSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy} will only keep the
last non-zero length message with the {@link org.apache.activemq.command.ActiveMQMessage}.RETAIN_PROPERTY.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='wrapped' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:fixedCountSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:fixedSizedSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:lastImageSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:noSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:queryBasedSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:retainedMessageSubscriptionRecoveryPolicy'/>
              <xs:element ref='tns:timedSubscriptionRecoveryPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='wrapped' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy -->
  <xs:element name='roundRobinDispatchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Simple dispatch policy that sends a message to every subscription that
matches the message.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.RuntimeConfigurationPlugin -->
  <xs:element name='runtimeConfigurationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Broker plugin that will monitor the broker xml configuration for
changes and selectively apply those changes to the running broker.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='checkPeriod' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.SharedFileLocker -->
  <xs:element name='shared-file-locker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an exclusive lock on a database to avoid multiple brokers running
against the same logical database.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='lockable' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='directory' type='xs:string'/>
      <xs:attribute name='failIfLocked' type='xs:boolean'/>
      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
      <xs:attribute name='lockable' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy -->
  <xs:element name='sharedDeadLetterStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A default implementation of {@link DeadLetterStrategy} which uses
a constant destination.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='deadLetterQueue' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='deadLetterQueue' type='xs:string'/>
      <xs:attribute name='enableAudit' type='xs:boolean'/>
      <xs:attribute name='expiration' type='xs:long'/>
      <xs:attribute name='processExpired' type='xs:boolean'/>
      <xs:attribute name='processNonPersistent' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.SimpleAuthenticationPlugin -->
  <xs:element name='simpleAuthenticationPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Provides a simple authentication plugin
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='userGroups' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the groups a user is in. The key is the user name and the value is a
Set of groups
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='userPasswords' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the map indexed by user name with the value the password
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='users' minOccurs='0' maxOccurs='unbounded'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets individual users for authentication
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='anonymousAccessAllowed' type='xs:boolean'/>
      <xs:attribute name='anonymousGroup' type='xs:string'/>
      <xs:attribute name='anonymousUser' type='xs:string'/>
      <xs:attribute name='userGroups' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the groups a user is in. The key is the user name and the value is a
Set of groups
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='userPasswords' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the map indexed by user name with the value the password
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.SimpleAuthorizationMap -->
  <xs:element name='simpleAuthorizationMap'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An AuthorizationMap which is configured with individual DestinationMaps for
each operation.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminACLs' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationMap'/>
              <xs:element ref='tns:policyMap'/>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='readACLs' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationMap'/>
              <xs:element ref='tns:policyMap'/>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempDestinationAuthorizationEntry' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:tempDestinationAuthorizationEntry'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='writeACLs' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:authorizationMap'/>
              <xs:element ref='tns:policyMap'/>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminACLs' type='xs:string'/>
      <xs:attribute name='readACLs' type='xs:string'/>
      <xs:attribute name='tempDestinationAuthorizationEntry' type='xs:string'/>
      <xs:attribute name='writeACLs' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.SimpleDispatchPolicy -->
  <xs:element name='simpleDispatchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Simple dispatch policy that sends a message to every subscription that
matches the message.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.SimpleDispatchSelector -->
  <xs:element name='simpleDispatchSelector'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Simple dispatch policy that determines if a message can be sent to a subscription
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.network.jms.SimpleJmsMessageConvertor -->
  <xs:element name='simpleJmsMessageConvertor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Converts Message from one JMS to another
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='connection' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.group.SimpleMessageGroupMapFactory -->
  <xs:element name='simpleMessageGroupMapFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A factory to create instances of {@link SimpleMessageGroupMap} when implementing the 
<a href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.spring.SpringSslContext -->
  <xs:element name='sslContext'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Extends the SslContext so that it's easier to configure from spring.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='SSLContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='keyManagers' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='secureRandom' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='trustManagers' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='SSLContext' type='xs:string'/>
      <xs:attribute name='crlPath' type='xs:string'/>
      <xs:attribute name='keyStore' type='xs:string'/>
      <xs:attribute name='keyStoreAlgorithm' type='xs:string'/>
      <xs:attribute name='keyStoreKeyPassword' type='xs:string'/>
      <xs:attribute name='keyStorePassword' type='xs:string'/>
      <xs:attribute name='keyStoreType' type='xs:string'/>
      <xs:attribute name='protocol' type='xs:string'/>
      <xs:attribute name='provider' type='xs:string'/>
      <xs:attribute name='secureRandom' type='xs:string'/>
      <xs:attribute name='secureRandomAlgorithm' type='xs:string'/>
      <xs:attribute name='trustStore' type='xs:string'/>
      <xs:attribute name='trustStoreAlgorithm' type='xs:string'/>
      <xs:attribute name='trustStorePassword' type='xs:string'/>
      <xs:attribute name='trustStoreType' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.Statements -->
  <xs:element name='statements'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='createLockSchemaStatements' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='createSchemaStatements' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='dropSchemaStatements' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='addMessageStatement' type='xs:string'/>
      <xs:attribute name='binaryDataType' type='xs:string'/>
      <xs:attribute name='clearDurableLastAckInTxStatement' type='xs:string'/>
      <xs:attribute name='clearXidFlagStatement' type='xs:string'/>
      <xs:attribute name='containerNameDataType' type='xs:string'/>
      <xs:attribute name='createDurableSubStatement' type='xs:string'/>
      <xs:attribute name='currentDateTimeStatement' type='xs:string'/>
      <xs:attribute name='deleteOldMessagesStatementWithPriority' type='xs:string'/>
      <xs:attribute name='deleteSubscriptionStatement' type='xs:string'/>
      <xs:attribute name='destinationMessageCountStatement' type='xs:string'/>
      <xs:attribute name='dropAckPKAlterStatementEnd' type='xs:string'/>
      <xs:attribute name='durableSubAcksTableName' type='xs:string'/>
      <xs:attribute name='durableSubscriberMessageCountStatement' type='xs:string'/>
      <xs:attribute name='durableSubscriberMessageCountStatementWithPriority' type='xs:string'/>
      <xs:attribute name='findAcksPendingOutcomeStatement' type='xs:string'/>
      <xs:attribute name='findAllDestinationsStatement' type='xs:string'/>
      <xs:attribute name='findAllDurableSubMessagesStatement' type='xs:string'/>
      <xs:attribute name='findAllDurableSubsStatement' type='xs:string'/>
      <xs:attribute name='findAllMessageIdsStatement' type='xs:string'/>
      <xs:attribute name='findAllMessagesStatement' type='xs:string'/>
      <xs:attribute name='findDurableSubMessagesStatement' type='xs:string'/>
      <xs:attribute name='findDurableSubStatement' type='xs:string'/>
      <xs:attribute name='findLastSequenceIdInAcksStatement' type='xs:string'/>
      <xs:attribute name='findLastSequenceIdInMsgsStatement' type='xs:string'/>
      <xs:attribute name='findMessageByIdStatement' type='xs:string'/>
      <xs:attribute name='findMessageSequenceIdStatement' type='xs:string'/>
      <xs:attribute name='findMessageStatement' type='xs:string'/>
      <xs:attribute name='findNextMessagesByPriorityStatement' type='xs:string'/>
      <xs:attribute name='findNextMessagesStatement' type='xs:string'/>
      <xs:attribute name='findOpsPendingOutcomeStatement' type='xs:string'/>
      <xs:attribute name='findXidByIdStatement' type='xs:string'/>
      <xs:attribute name='insertDurablePriorityAckStatement' type='xs:string'/>
      <xs:attribute name='lastAckedDurableSubscriberMessageStatement' type='xs:string'/>
      <xs:attribute name='lastProducerSequenceIdStatement' type='xs:string'/>
      <xs:attribute name='leaseObtainStatement' type='xs:string'/>
      <xs:attribute name='leaseOwnerStatement' type='xs:string'/>
      <xs:attribute name='leaseUpdateStatement' type='xs:string'/>
      <xs:attribute name='lockCreateStatement' type='xs:string'/>
      <xs:attribute name='lockTableName' type='xs:string'/>
      <xs:attribute name='lockUpdateStatement' type='xs:string'/>
      <xs:attribute name='longDataType' type='xs:string'/>
      <xs:attribute name='messageTableName' type='xs:string'/>
      <xs:attribute name='msgIdDataType' type='xs:string'/>
      <xs:attribute name='nextDurableSubscriberMessageStatement' type='xs:string'/>
      <xs:attribute name='removeAllMessagesStatement' type='xs:string'/>
      <xs:attribute name='removeAllSubscriptionsStatement' type='xs:string'/>
      <xs:attribute name='removeMessageStatment' type='xs:string'/>
      <xs:attribute name='selectDurablePriorityAckStatement' type='xs:string'/>
      <xs:attribute name='sequenceDataType' type='xs:string'/>
      <xs:attribute name='stringIdDataType' type='xs:string'/>
      <xs:attribute name='tablePrefix' type='xs:string'/>
      <xs:attribute name='updateDurableLastAckInTxStatement' type='xs:string'/>
      <xs:attribute name='updateDurableLastAckStatement' type='xs:string'/>
      <xs:attribute name='updateDurableLastAckWithPriorityInTxStatement' type='xs:string'/>
      <xs:attribute name='updateDurableLastAckWithPriorityStatement' type='xs:string'/>
      <xs:attribute name='updateLastPriorityAckRowOfDurableSubStatement' type='xs:string'/>
      <xs:attribute name='updateMessageStatement' type='xs:string'/>
      <xs:attribute name='updateXidFlagStatement' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='useLockCreateWhereClause' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.StatisticsBrokerPlugin -->
  <xs:element name='statisticsBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A StatisticsBrokerPlugin
You can retrieve a Map Message for a Destination - or
Broker containing statistics as key-value pairs The message must contain a
replyTo Destination - else its ignored
To retrieve stats on the broker send a empty message to ActiveMQ.Statistics.Broker (Queue or Topic)
With a replyTo set to the destination you want the stats returned to.
To retrieve stats for a destination - e.g. foo - send an empty message to ActiveMQ.Statistics.Destination.foo
- this works with wildcards to - you get a message for each wildcard match on the replyTo destination.
The stats message is a MapMessage populated with statistics for the target
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy -->
  <xs:element name='storeCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy -->
  <xs:element name='storeDurableSubscriberCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages for a durable
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='immediatePriorityDispatch' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Ensure that new higher priority messages will get an immediate dispatch
rather than wait for the end of the current cursor batch.
Useful when there is a large message backlog and intermittent high priority messages.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useCache' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.StoreUsage -->
  <xs:element name='storeUsage'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Used to keep track of how much of something is being used so that a
productive working set usage can be controlled. Main use case is manage
memory usage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultUsageCapacity'/>
              <xs:element ref='tns:usageCapacity'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='limit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
"1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='limiter' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='parent' type='xs:string'/>
      <xs:attribute name='percentLimit' type='xs:integer'/>
      <xs:attribute name='percentUsage' type='xs:integer'/>
      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
manager.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='pollingTime' type='xs:integer'/>
      <xs:attribute name='store' type='xs:string'/>
      <xs:attribute name='usagePortion' type='xs:float'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.StreamJDBCAdapter -->
  <xs:element name='streamJDBCAdapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This JDBCAdapter inserts and extracts BLOB data using the
setBinaryStream()/getBinaryStream() operations.

The databases/JDBC drivers that use this adapter are:
<ul>
<li>Axion</li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.StrictOrderDispatchPolicy -->
  <xs:element name='strictOrderDispatchPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Dispatch policy that causes every subscription to see messages in the same
order.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.SybaseJDBCAdapter -->
  <xs:element name='sybase-jdbc-adapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A JDBC Adapter for Sybase databases
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.SystemUsage -->
  <xs:element name='systemUsage'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Holder for Usage instances for memory, store and temp files Main use case is
manage memory usage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adapter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapter'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:memoryPersistenceAdapter'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='jobSchedulerStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='jobSchedulerUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jobSchedulerUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='memoryUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:memoryUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:systemUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='storeUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:storeUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempStore' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='tempUsage' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:tempUsage'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adapter' type='xs:string'/>
      <xs:attribute name='checkLimitsLogLevel' type='xs:string'/>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='jobSchedulerStore' type='xs:string'/>
      <xs:attribute name='jobSchedulerUsage' type='xs:string'/>
      <xs:attribute name='memoryUsage' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='parent' type='xs:string'/>
      <xs:attribute name='sendFailIfNoSpace' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not a send() should fail if there is no space free. The
default value is false which means to block the send() method until space
becomes available
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sendFailIfNoSpaceAfterTimeout' type='xs:long'/>
      <xs:attribute name='sendFailIfNoSpaceExplicitySet' type='xs:boolean'/>
      <xs:attribute name='storeUsage' type='xs:string'/>
      <xs:attribute name='tempStore' type='xs:string'/>
      <xs:attribute name='tempUsage' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.thread.TaskRunnerFactory -->
  <xs:element name='taskRunnerFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Manages the thread pool for long running tasks. Long running tasks are not
always active but when they are active, they may need a few iterations of
processing for them to become idle. The manager ensures that each task is
processes but that no one task overtakes the system. This is kinda like
cooperative multitasking.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='threadClassLoader' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='daemon' type='xs:boolean'/>
      <xs:attribute name='dedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='maxIterationsPerRun' type='xs:integer'/>
      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='priority' type='xs:integer'/>
      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
      <xs:attribute name='shutdownAwaitTermination' type='xs:long'/>
      <xs:attribute name='threadClassLoader' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.security.TempDestinationAuthorizationEntry -->
  <xs:element name='tempDestinationAuthorizationEntry'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an entry in a {@link DefaultAuthorizationMap} for assigning
different operations (read, write, admin) of user roles to a temporary
destination
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='destination' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='readACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='writeACLs' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='admin' type='xs:string'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='groupClass' type='xs:string'/>
      <xs:attribute name='queue' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='read' type='xs:string'/>
      <xs:attribute name='tempQueue' type='xs:boolean'/>
      <xs:attribute name='tempTopic' type='xs:boolean'/>
      <xs:attribute name='topic' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A helper method to set the destination from a configuration file
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='write' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.command.ActiveMQTempQueue -->
  <xs:element name='tempQueue'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ActiveMQ Temporary Queue Destination
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='connection' type='xs:string'/>
      <xs:attribute name='connectionId' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='physicalName' type='xs:string'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sequenceId' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.command.ActiveMQTempTopic -->
  <xs:element name='tempTopic'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ActiveMQ Temporary Topic Destination
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='connection' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='connection' type='xs:string'/>
      <xs:attribute name='connectionId' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='physicalName' type='xs:string'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sequenceId' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.TempUsage -->
  <xs:element name='tempUsage'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Used to keep track of how much of something is being used so that a
productive working set usage can be controlled. Main use case is manage
memory usage.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='limiter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultUsageCapacity'/>
              <xs:element ref='tns:usageCapacity'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='parent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='store' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:pListStoreImpl'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='limit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
"1g" can be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='limiter' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='parent' type='xs:string'/>
      <xs:attribute name='percentLimit' type='xs:integer'/>
      <xs:attribute name='percentUsage' type='xs:integer'/>
      <xs:attribute name='percentUsageMinDelta' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
manager.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='pollingTime' type='xs:integer'/>
      <xs:attribute name='store' type='xs:string'/>
      <xs:attribute name='usagePortion' type='xs:float'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.TimeStampingBrokerPlugin -->
  <xs:element name='timeStampingBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Broker interceptor which updates a JMS Client's timestamp on the message
with a broker timestamp. Useful when the clocks on client machines are known
to not be correct and you can only trust the time set on the broker machines.

Enabling this plugin will break JMS compliance since the timestamp that the
producer sees on the messages after as send() will be different from the
timestamp the consumer will observe when he receives the message. This plugin
is not enabled in the default ActiveMQ configuration.

2 new attributes have been added which will allow the administrator some override control
over the expiration time for incoming messages:

Attribute 'zeroExpirationOverride' can be used to apply an expiration
time to incoming messages with no expiration defined (messages that would never expire)

Attribute 'ttlCeiling' can be used to apply a limit to the expiration time
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='futureOnly' type='xs:boolean'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='processNetworkMessages' type='xs:boolean'/>
      <xs:attribute name='ttlCeiling' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            setter method for ttlCeiling
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='zeroExpirationOverride' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            setter method for zeroExpirationOverride
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.TimedSubscriptionRecoveryPolicy -->
  <xs:element name='timedSubscriptionRecoveryPolicy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This implementation of {@link SubscriptionRecoveryPolicy} will keep a timed
buffer of messages around in memory and use that to recover new
subscriptions.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='broker' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='broker' type='xs:string'/>
      <xs:attribute name='recoverDuration' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.command.ActiveMQTopic -->
  <xs:element name='topic'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An ActiveMQ Topic
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='compositeDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:queue'/>
              <xs:element ref='tns:tempQueue'/>
              <xs:element ref='tns:tempTopic'/>
              <xs:element ref='tns:topic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='physicalName' type='xs:string'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.TraceBrokerPathPlugin -->
  <xs:element name='traceBrokerPathPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The TraceBrokerPathPlugin can be used in a network of Brokers. Each Broker
that has the plugin configured, will add it's brokerName to the content
of a JMS Property. If all Brokers have this property enabled, the path the
message actually took through the network can be seen in the defined property.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='stampProperty' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.TransactDatabaseLocker -->
  <xs:element name='transact-database-locker'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Represents an exclusive lock on a database to avoid multiple brokers running
against the same logical database.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='dataSource' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='exceptionHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='lockable' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:jdbcPersistenceAdapter'/>
              <xs:element ref='tns:journalPersistenceAdapterFactory'/>
              <xs:element ref='tns:journaledJDBC'/>
              <xs:element ref='tns:kahaDB'/>
              <xs:element ref='tns:levelDB'/>
              <xs:element ref='tns:mKahaDB'/>
              <xs:element ref='tns:replicatedLevelDB'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='createTablesOnStartup' type='xs:boolean'/>
      <xs:attribute name='dataSource' type='xs:string'/>
      <xs:attribute name='exceptionHandler' type='xs:string'/>
      <xs:attribute name='failIfLocked' type='xs:boolean'/>
      <xs:attribute name='lockAcquireSleepInterval' type='xs:long'/>
      <xs:attribute name='lockable' type='xs:string'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='queryTimeout' type='xs:integer'/>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.store.jdbc.adapter.TransactJDBCAdapter -->
  <xs:element name='transact-jdbc-adapter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A JDBC Adapter for Transact-SQL based databases such as SQL Server or Sybase
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='statements' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:statements'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='batchStatements' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the number of statements to process as a single batch DB update
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='batchStatments' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This value batchStatments is deprecated and will be removed in a future release.  Use batchStatements instead (Note the 'e' in Statement)"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxRows' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the max value for statement maxRows, used to limit jdbc queries
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='statements' type='xs:string'/>
      <xs:attribute name='useExternalMessageReferences' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.TransportConnector -->
  <xs:element name='transportConnector'>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='brokerInfo' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='brokerService' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              This is called by the BrokerService right before it starts the transport.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:broker'/>
              <xs:element ref='tns:brokerService'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='discoveryAgent' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageAuthorizationPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to decide if the current connection is authorized to
consume a given message
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='publishedAddressPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Gets the currently configured policy for creating the published connection address of this
TransportConnector.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:publishedAddressPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='server' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='taskRunnerFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='allowLinkStealing' type='xs:boolean'/>
      <xs:attribute name='auditNetworkProducers' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
Note: does not work with conduit=false, networked composite destinations or networked virtual topics
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerInfo' type='xs:string'/>
      <xs:attribute name='brokerService' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            This is called by the BrokerService right before it starts the transport.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='disableAsyncDispatch' type='xs:boolean'/>
      <xs:attribute name='discoveryAgent' type='xs:string'/>
      <xs:attribute name='discoveryUri' type='xs:string'/>
      <xs:attribute name='enableStatusMonitor' type='xs:boolean'/>
      <xs:attribute name='maximumConsumersAllowedPerConnection' type='xs:integer'/>
      <xs:attribute name='maximumProducersAllowedPerConnection' type='xs:integer'/>
      <xs:attribute name='messageAuthorizationPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to decide if the current connection is authorized to
consume a given message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='publishedAddressPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the currently configured policy for creating the published connection address of this
TransportConnector.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rebalanceClusterClients' type='xs:boolean'/>
      <xs:attribute name='server' type='xs:string'/>
      <xs:attribute name='taskRunnerFactory' type='xs:string'/>
      <xs:attribute name='updateClusterClients' type='xs:boolean'/>
      <xs:attribute name='updateClusterClientsOnRemove' type='xs:boolean'/>
      <xs:attribute name='updateClusterFilter' type='xs:string'/>
      <xs:attribute name='uri' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the server transport URI to use if there is not a
{@link TransportServer} configured via the
{@link #setServer(TransportServer)} method. This value is used to lazy
create a {@link TransportServer} instance
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.util.UDPTraceBrokerPlugin -->
  <xs:element name='udpTraceBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A Broker interceptor which allows you to trace all operations to a UDP
socket.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='address' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='adminConnectionContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='next' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:destinationPathSeparatorPlugin'/>
              <xs:element ref='tns:destinationsPlugin'/>
              <xs:element ref='tns:forcePersistencyModeBroker'/>
              <xs:element ref='tns:loggingBrokerPlugin'/>
              <xs:element ref='tns:multicastTraceBrokerPlugin'/>
              <xs:element ref='tns:redeliveryPlugin'/>
              <xs:element ref='tns:timeStampingBrokerPlugin'/>
              <xs:element ref='tns:traceBrokerPathPlugin'/>
              <xs:element ref='tns:udpTraceBrokerPlugin'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='wireFormat' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='wireFormatFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='address' type='xs:string'/>
      <xs:attribute name='adminConnectionContext' type='xs:string'/>
      <xs:attribute name='broadcast' type='xs:boolean'/>
      <xs:attribute name='destination' type='xs:string'/>
      <xs:attribute name='maxTraceDatagramSize' type='xs:integer'/>
      <xs:attribute name='next' type='xs:string'/>
      <xs:attribute name='wireFormat' type='xs:string'/>
      <xs:attribute name='wireFormatFactory' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.UniquePropertyMessageEvictionStrategy -->
  <xs:element name='uniquePropertyMessageEvictionStrategy'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An eviction strategy which evicts the oldest message within messages with the same property value
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='evictExpiredMessagesHighWatermark' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the high water mark on which we will eagerly evict expired messages from RAM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='propertyName' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.usage.UsageCapacity -->
  <xs:element name='usageCapacity'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Identify if a limit has been reached
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='limit' type='xs:long'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor -->
  <xs:element name='virtualDestinationInterceptor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Implements <a
href="http://activemq.apache.org/virtual-destinations.html">Virtual
Topics</a>.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='virtualDestinations' minOccurs='0' maxOccurs='unbounded'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='unbounded'>
              <xs:element ref='tns:compositeQueue'/>
              <xs:element ref='tns:compositeTopic'/>
              <xs:element ref='tns:virtualTopic'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin -->
  <xs:element name='virtualSelectorCacheBrokerPlugin'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A plugin which allows the caching of the selector from a subscription queue.
<p/>
This stops the build-up of unwanted messages, especially when consumers may
disconnect from time to time when using virtual destinations.
<p/>
This is influenced by code snippets developed by Maciej Rakowicz
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='ignoreWildcardSelectors' type='xs:boolean'/>
      <xs:attribute name='persistFile' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the location of the persistent cache
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='persistInterval' type='xs:long'/>
      <xs:attribute name='singleSelectorPerDestination' type='xs:boolean'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.virtual.VirtualTopic -->
  <xs:element name='virtualTopic'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Creates <a href="http://activemq.org/site/virtual-destinations.html">Virtual
Topics</a> using a prefix and postfix. The virtual destination creates a
wildcard that is then used to look up all active queue subscriptions which
match.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='concurrentSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When true, dispatch to matching destinations in parallel (in multiple threads)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='local' type='xs:boolean'/>
      <xs:attribute name='name' type='xs:string'/>
      <xs:attribute name='postfix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets any postix used to identify the queue consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='prefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix wildcard used to identify the queue consumers for a given
topic
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='selectorAware' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Indicates whether the selectors of consumers are used to determine
dispatch to a virtual destination, when true only messages matching an
existing consumer will be dispatched.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transactedSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When true, dispatch to matching destinations always uses a transaction.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy -->
  <xs:element name='vmCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages held
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy -->
  <xs:element name='vmDurableCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy -->
  <xs:element name='vmQueueCursor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Pending messages
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.activemq.spring.ActiveMQXAConnectionFactory -->
  <xs:element name='xaConnectionFactory'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A <a href="http://www.springframework.org/">Spring</a> enhanced XA connection
factory which will automatically use the Spring bean name as the clientIDPrefix property
so that connections created have client IDs related to your Spring.xml file for
easier comprehension from <a href="http://activemq.apache.org/jmx.html">JMX</a>.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded"><xs:choice>
        <xs:element name='blobTransferPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the policy used to describe how out-of-band BLOBs (Binary Large
OBjects) are transferred from producers to brokers to consumers
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='clientIdGenerator' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='clientInternalExceptionListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='connectionIdGenerator' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='exceptionListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='prefetchPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the <a
href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
policy</a> for consumers created by this connection.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:prefetchPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='properties' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the properties from this instance for storing in JNDI
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicy' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the global default redelivery policy to be used when a message is delivered
but the session is rolled back
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicy'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='redeliveryPolicyMap' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the global redelivery policy mapping to be used when a message is delivered
but the session is rolled back
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:redeliveryPolicyMap'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='rejectedTaskHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionTaskRunner' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:taskRunnerFactory'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='transformer' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the transformer used to transform messages before they are sent on
to the JMS bus or when they are received from the bus but before they are
delivered to the JMS client
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='transportListener' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Allows a listener to be configured on the ConnectionFactory so that when this factory is used
with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
a transport listener.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:choice></xs:choice>
      <xs:attribute name='alwaysSessionAsync' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this flag is not set then a separate thread is not used for dispatching messages for each Session in
the Connection. However, a separate thread is always used if there is more than one session, or the session
isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
happens asynchronously.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='alwaysSyncSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set true if always require messages to be sync sent
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='auditDepth' type='xs:integer'/>
      <xs:attribute name='auditMaximumProducerNumber' type='xs:integer'/>
      <xs:attribute name='beanName' type='xs:string'/>
      <xs:attribute name='blobTransferPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the policy used to describe how out-of-band BLOBs (Binary Large
OBjects) are transferred from producers to brokers to consumers
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='brokerURL' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the <a
href="http://activemq.apache.org/configuring-transports.html">connection
URL</a> used to connect to the ActiveMQ broker.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='checkForDuplicates' type='xs:boolean'/>
      <xs:attribute name='clientID' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS clientID to use for the created connection. Note that this
can only be used by one connection at once so generally its a better idea
to set the clientID on a Connection
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='clientIDPrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix used by autogenerated JMS Client ID values which are used
if the JMS client does not explicitly specify on.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='clientIdGenerator' type='xs:string'/>
      <xs:attribute name='clientInternalExceptionListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='closeTimeout' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the timeout before a close is considered complete. Normally a
close() on a connection waits for confirmation from the broker; this
allows that operation to timeout to save the client hanging if there is
no broker
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectionIDPrefix' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the prefix used by connection id generator
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='connectionIdGenerator' type='xs:string'/>
      <xs:attribute name='consumerExpiryCheckEnabled' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Controls whether message expiration checking is done in each MessageConsumer
prior to dispatching a message.  Disabling this check can lead to consumption
of expired messages.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='consumerFailoverRedeliveryWaitPeriod' type='xs:long'/>
      <xs:attribute name='copyMessageOnSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Should a JMS message be copied to a new JMS Message object as part of the
send() method in JMS. This is enabled by default to be compliant with the
JMS specification. You can disable it if you do not mutate JMS messages
after they are sent for a performance boost
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='disableTimeStampsByDefault' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not timestamps on messages should be disabled or not. If
you disable them it adds a small performance boost.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='dispatchAsync' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables the default setting of whether or not consumers have
their messages <a
href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
synchronously or asynchronously by the broker</a>. For non-durable
topics for example we typically dispatch synchronously by default to
minimize context switches which boost performance. However sometimes its
better to go slower to ensure that a single blocked consumer socket does
not block delivery to other consumers.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='exceptionListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
an exception listener.
<p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
on connection (as it will be if more than one connection is subsequently created by this connection factory)
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='exclusiveConsumer' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables or disables whether or not queue consumers should be exclusive or
not for example to preserve ordering when not using <a
href="http://activemq.apache.org/message-groups.html">Message Groups</a>
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxThreadPoolSize' type='xs:integer'/>
      <xs:attribute name='messagePrioritySupported' type='xs:boolean'/>
      <xs:attribute name='nestedMapAndListEnabled' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables/disables whether or not Message properties and MapMessage entries
support <a
href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
Structures</a> of Map and List objects
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='nonBlockingRedelivery' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When true a MessageConsumer will not stop Message delivery before re-delivering Messages
from a rolled back transaction.  This implies that message order will not be preserved and
also will result in the TransactedIndividualAck option to be enabled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='objectMessageSerializationDefered' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            When an object is set on an ObjectMessage, the JMS spec requires the
object to be serialized by that set method. Enabling this flag causes the
object to not get serialized. The object may subsequently get serialized
if the message needs to be sent over a socket or stored to disk.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizeAcknowledge' type='xs:boolean'/>
      <xs:attribute name='optimizeAcknowledgeTimeOut' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The max time in milliseconds between optimized ack batches
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizedAckScheduledAckInterval' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
will not do any background Message acknowledgment.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='optimizedMessageDispatch' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            If this flag is set then an larger prefetch limit is used - only
applicable for durable topic subscribers.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='password' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS password used for connections created from this factory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='prefetchPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the <a
href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
policy</a> for consumers created by this connection.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='producerWindowSize' type='xs:integer'/>
      <xs:attribute name='properties' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the properties from this instance for storing in JNDI
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='redeliveryPolicy' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the global default redelivery policy to be used when a message is delivered
but the session is rolled back
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='redeliveryPolicyMap' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the global redelivery policy mapping to be used when a message is delivered
but the session is rolled back
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rejectedTaskHandler' type='xs:string'/>
      <xs:attribute name='rmIdFromConnectionId' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            uses the connection id as the resource identity for XAResource.isSameRM
ensuring join will only occur on a single connection
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sendAcksAsync' type='xs:boolean'/>
      <xs:attribute name='sendTimeout' type='xs:integer'/>
      <xs:attribute name='sessionTaskRunner' type='xs:string'/>
      <xs:attribute name='statsEnabled' type='xs:boolean'/>
      <xs:attribute name='transactedIndividualAck' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            when true, submit individual transacted acks immediately rather than with transaction completion.
This allows the acks to represent delivery status which can be persisted on rollback
Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transformer' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the transformer used to transform messages before they are sent on
to the JMS bus or when they are received from the bus but before they are
delivered to the JMS client
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='transportListener' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Allows a listener to be configured on the ConnectionFactory so that when this factory is used
with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
a transport listener.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useAsyncSend' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Forces the use of <a
href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
adds a massive performance boost; but means that the send() method will
return immediately whether the message has been sent or not which could
lead to message loss.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useBeanNameAsClientIdPrefix' type='xs:boolean'/>
      <xs:attribute name='useCompression' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables the use of compression of the message bodies
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='useDedicatedTaskRunner' type='xs:boolean'/>
      <xs:attribute name='useRetroactiveConsumer' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets whether or not retroactive consumers are enabled. Retroactive
consumers allow non-durable topic subscribers to receive old messages
that were published before the non-durable subscriber started.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='userName' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the JMS userName used by connections created by this factory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='warnAboutUnstartedConnectionTimeout' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Enables the timeout from a connection creation to when a warning is
generated if the connection is not properly started via
{@link Connection#start()} and a message is received by a consumer. It is
a very common gotcha to forget to <a
href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
the connection</a> so this option makes the default case to create a
warning if the user forgets. To disable the warning just set the value to <
0 (say -1).
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='watchTopicAdvisories' type='xs:boolean'/>
      <xs:attribute name='xaAckMode' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


</xs:schema>
