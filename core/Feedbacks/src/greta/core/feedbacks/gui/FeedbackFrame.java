package greta.core.feedbacks.gui;

import com.illposed.osc.OSCMessage;
import com.illposed.osc.OSCSerializeException;
import com.illposed.osc.transport.udp.OSCPortOut;
import greta.core.feedbacks.Callback;
import greta.core.feedbacks.CallbackPerformer;
import greta.core.feedbacks.FeedbackEmitter;
import greta.core.feedbacks.FeedbackPerformer;
import greta.core.feedbacks.Feedbacks;
import greta.core.feedbacks.TemporizableList;
import greta.core.intentions.Intention;
import greta.core.intentions.IntentionPerformer;
import greta.core.signals.Signal;
import greta.core.signals.SignalEmitter;
import greta.core.signals.SignalPerformer;
import greta.core.signals.SpeechSignal;
import greta.core.signals.gesture.GestureSignal;
import greta.core.util.CharacterManager;
import greta.core.util.Mode;
import greta.core.util.enums.DistanceType;
import greta.core.util.id.ID;
import greta.core.util.id.IDProvider;
import greta.core.util.log.Logs;
import greta.core.util.time.Temporizable;
import greta.core.util.time.TimeMarker;
import greta.core.util.time.Timer;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Michele
 */


public class FeedbackFrame extends javax.swing.JFrame implements CallbackPerformer, FeedbackEmitter, SignalPerformer, IntentionPerformer, SignalEmitter   {

    /**
     * Creates new form FeedbackFrame
     */
    //public Feedbacks feedback;
    /*public FeedbackFrame(CharacterManager cm) {
        feedback=new Feedbacks(cm);
        initComponents();
        port.setEnabled(false);
    }
    */
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        port = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        use_osc = new javax.swing.JCheckBox();
        set_button = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "FeedBackOSC", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 18))); // NOI18N

        port.setText("9000");
        port.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                portActionPerformed(evt);
            }
        });

        jLabel1.setText("Port");

        use_osc.setText("Enable");
        use_osc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                use_oscActionPerformed(evt);
            }
        });

        set_button.setText("Set");
        set_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                set_buttonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(42, 42, 42)
                        .addComponent(port, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(use_osc)
                    .addComponent(set_button))
                .addContainerGap(218, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(use_osc)
                .addGap(21, 21, 21)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(port, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(52, 52, 52)
                .addComponent(set_button)
                .addContainerGap(70, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(47, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(29, 29, 29)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void portActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_portActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_portActionPerformed

    private void use_oscActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_use_oscActionPerformed
        // TODO add your handling code here:
        if(use_osc.isSelected()){
            port.setEnabled(true);
        }else{
            port.setEnabled(false);;
        }
    }//GEN-LAST:event_use_oscActionPerformed

    private void set_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_set_buttonActionPerformed
                try {
            // TODO add your handling code here:
            this.setOscPort(Integer.valueOf(port.getText()));
            this.setOscOut(new OSCPortOut(InetAddress.getLocalHost(), this.getOscPort()));
        } catch (UnknownHostException ex) {
            Logger.getLogger(FeedbackFrame.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(FeedbackFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_set_buttonActionPerformed



    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JTextField port;
    private javax.swing.JButton set_button;
    private javax.swing.JCheckBox use_osc;
    // End of variables declaration//GEN-END:variables

private ArrayList<SignalPerformer> signal_performers = new ArrayList<SignalPerformer>();
List<Signal> signals = new ArrayList<Signal>();
     

    private class FeedbackThread extends Thread {

        private boolean threadStarted;
        private boolean still_running=false;
        private Map map=new HashMap();  
        public CharacterManager charactermanager;
        private List<Boolean> li= new ArrayList<Boolean>();

        public FeedbackThread(CharacterManager cm) {
            this.setDaemon(true);
            threadStarted = true;
            charactermanager=cm;
        }

        public void stopTh() {
            threadStarted = false;
        }
        
        TimeMarker start_timemarker;

        @Override
        public void run() {
           
            while (threadStarted) {
                synchronized (FeedbackFrame.this) {
                    //System.out.println("listStartedAnimations.isEmpty()"+listStartedAnimations.isEmpty());
                    if (!listStartedAnimations.isEmpty()) {
                        for (int i = 0; i < listStartedAnimations.size(); i++) {

                            TemporizableList tmpList = listStartedAnimations.get(i);

                            if (speech_sgnl == null || speech_sgnl.getId().equals("")){
                                List<Temporizable> array_signal = tmpList.getPendingList();
                                for(Temporizable tze : array_signal){
                                    if (tze instanceof SpeechSignal){
                                        speech_sgnl = (SpeechSignal) tze;
                                    }
                                }
                            }

                            tmpList.update();

                            TimeMarker last_timemarker = tmpList.updateTimeMarker(speech_sgnl);
                            start_timemarker=last_timemarker;

                            if(last_timemarker.getName() != "" && last_timemarker.getName() != oldTimeMarker_ID){
                                oldTimeMarker_ID = last_timemarker.getName();
                                for (FeedbackPerformer feedbackPerformer : listFeedbackPerformer) {
                                    feedbackPerformer.performFeedback(tmpList.getID(), "end", speech_sgnl, last_timemarker);
                                }
                            }

                            List<Temporizable> listLastStarted = tmpList.listLastStarted();
                            List<Temporizable> listFinished = tmpList.listFinished();
                            if (!listLastStarted.isEmpty()) {
                                for (FeedbackPerformer feedbackPerformer : listFeedbackPerformer) {
                                    //feedbackPerformer.performFeedback(tmpList.getID(), "started", listLastStarted, last_timemarker);
                                    feedbackPerformer.performFeedback(tmpList.getID(), "started", listLastStarted);
                                }
                            }
                            if (!listFinished.isEmpty()) {
                                for (FeedbackPerformer feedbackPerformer : listFeedbackPerformer) {
                                    feedbackPerformer.performFeedback(tmpList.getID(), "ended", listFinished);
                                }
                            }


                            if (tmpList.isFinished()) {
                                listStartedAnimations.remove(i);
                                i--;
                            }
                        }
                    }
                }
                //System.out.println("IS STILL RUNNING:"+listStartedAnimations.size()+"   "+oscOut);
                if(listStartedAnimations.size()>0){
                    still_running=true;
                    charactermanager.setIsrunning(still_running);
                }else{
                    still_running=false;
                    charactermanager.setIsrunning(still_running);
                }
                
                li.clear();
                li.add(still_running);
                if(oscOut!=null && use_osc.isSelected()){
                    OSCMessage msg = new OSCMessage("/unity/animation_running",li); 
                    sendOSC("/", map);
                    map.put("unity/animation_running", still_running);
                    try {
                        //System.out.println(oscOut+"  "+msg.toString());
                        oscOut.send(msg);
                    } catch (IOException | OSCSerializeException ex) {
                    }
                }
                
                if(still_running && this.charactermanager.isTouch_computed() && this.charactermanager.getDistance()==DistanceType.INTIMATE){
                    
                    GestureSignal gs = new GestureSignal("1");
                    String[] gesture = this.charactermanager.getTouch_gesture_computed().split("=");
                    gs.setCategory(gesture[0]);
                    gs.setReference(gesture[1]);
                    gs.setStart(start_timemarker);
                    TimeMarker end_timeMarker=start_timemarker;
                    end_timeMarker.setValue(start_timemarker.getValue()+2);
                    gs.setEnd(end_timeMarker);
                    ID id = IDProvider.createID("1");
                    Mode mode = new Mode("blend");
                    signals.add(gs);
                    for (SignalPerformer performer : signal_performers) {
                         performer.performSignals(signals, id, mode);
                    }
                    
                }
                   
                
            }
            
        }
    }
    
            
    private void sendOSC(String root, Map<String,Boolean> map){
        try {
            for (String key : map.keySet()) {
                final List<Boolean> args = new ArrayList<>();
                args.add(map.get(key));
                OSCMessage msg = new OSCMessage(root+key, args);  
                if(oscOut!=null)
                    oscOut.send(msg);            
            }
        } catch (OSCSerializeException | IOException ex) {
        } 
    }   

    private CharacterManager charactermanager;
    /**
     * List of Pending Animations (waiting start or death) filled with every
     * incoming Intention or Signal (by IntentionPerforme and SignalPerformer)
     * emptied by "start" signals (by CallbackPerformer)
     */
    private List<TemporizableList> listPendingAnimations;
    /**
     * List of Dead Animations (waiting start or death) filled with every
     * incoming Intention or Signal (by IntentionPerforme and SignalPerformer)
     * emptied by "start" signals (by CallbackPerformer)
     */
    private List<TemporizableList> listDeadAnimations;
    private List<TemporizableList> listStoppedAnimations;
    private List<TemporizableList> listStartedAnimations;
    /**
     * In some cases, the callback "start anim id" can be received before the
     * reception of the animation "anim id", in that case, the callbalck is
     * added to listCallbackWithoutAnim The callback is stored until the
     * corresponding animation is received
     */
    private List<Callback> listCallbacksWithoutAnim;
    private List<FeedbackPerformer> listFeedbackPerformer;
    private FeedbackThread feedbackThread;
    private SpeechSignal speech_sgnl;
    public String oldTimeMarker_ID = "";
    private OSCPortOut oscOut = null;

    public OSCPortOut getOscOut() {
        return oscOut;
    }

    public void setOscOut(OSCPortOut oscOut) {
        this.oscOut = oscOut;
    }

    public int getOscPort() {
        return oscPort;
    }

    public void setOscPort(int oscPort) {
        this.oscPort = oscPort;
    }
    private int oscPort = 9000;   
    

    public FeedbackFrame(CharacterManager cm) {
        initComponents();
        port.setEnabled(false);
        this.charactermanager = cm;
        listPendingAnimations = new ArrayList<TemporizableList>();
        listDeadAnimations = new ArrayList<TemporizableList>();
        listStartedAnimations = new ArrayList<TemporizableList>();
        listStoppedAnimations = new ArrayList<TemporizableList>();
        listCallbacksWithoutAnim = new ArrayList<Callback>();
        listFeedbackPerformer = new ArrayList<FeedbackPerformer>();
        startThread();
    }

    public List<TemporizableList> getListPendingAnimations() {
        return listPendingAnimations;
    }


    public void setListPendingAnimations(List<TemporizableList> listPendingAnimations) {
        this.listPendingAnimations = listPendingAnimations;
    }

    public List<TemporizableList> getListDeadAnimations() {
        return listDeadAnimations;
    }

    public void setListDeadAnimations(List<TemporizableList> listDeadAnimations) {
        this.listDeadAnimations = listDeadAnimations;
    }

    public List<TemporizableList> getListStoppedAnimations() {
        return listStoppedAnimations;
    }

    public void setListStoppedAnimations(List<TemporizableList> listStoppedAnimations) {
        this.listStoppedAnimations = listStoppedAnimations;
    }

    public List<TemporizableList> getListStartedAnimations() {
        return listStartedAnimations;
    }

    public void setListStartedAnimations(List<TemporizableList> listStartedAnimations) {
        this.listStartedAnimations = listStartedAnimations;
    }

    public SpeechSignal getSpeech_sgnl() {
        return speech_sgnl;
    }

    public void setSpeech_sgnl(SpeechSignal speech_sgnl) {
        this.speech_sgnl = speech_sgnl;
    }

    public final void startThread() {
        System.out.println("START FEEDBACK THREAD");
        if (feedbackThread == null || !feedbackThread.isAlive()) {
            feedbackThread = new FeedbackThread(charactermanager);
            feedbackThread.start();
        }
    }

    public final void stopThread() {
        if (feedbackThread != null) {
            feedbackThread.stopTh();
        }
    }

    public synchronized void performAnimation(List<? extends Temporizable> temporizables, ID requestId) {
        Logs.debug("[Feedbacks] Animation received: " + requestId);
        listPendingAnimations.add(new TemporizableList(requestId, temporizables));
        // Cases when a callback on this anim was received before the animation
        Callback callback = findCallback(requestId);

        //while (greta.core.util.time.Timer.getTime() < )
        if (callback != null) {
            Logs.debug("[Feedbacks] Animation already has a callback " + requestId);
            performCallback(callback);
            listCallbacksWithoutAnim.remove(callback);
        }
    }
    /*
     * This function update the list of pending animations when a feedback is
     * received, i.e. when a start and its associated id are received
     */

    @Override
    public synchronized void performCallback(Callback callback) {
        Logs.debug("[Feedbacks|performCallback] " + callback.type() + " on anim " + callback.animId());
        TemporizableList tmpList;
        if ("dead".equals(callback.type())) {
            tmpList = findAnim(listPendingAnimations, callback.animId());
            if (tmpList != null) {
                tmpList.setDeadTime(callback.time());
                listDeadAnimations.add(tmpList);
                listPendingAnimations.remove(tmpList);
            } else {
                listCallbacksWithoutAnim.add(callback);
                Logs.debug("[Feedbacks] callback added to listCallbacksWithoutAnim for anim " + callback.animId());
            }
        }
        if ("start".equals(callback.type())) {

            tmpList = findAnim(listPendingAnimations, callback.animId());
            if (tmpList != null) {
                tmpList.setStartTime(callback.time());
                listStartedAnimations.add(tmpList);
                listPendingAnimations.remove(tmpList);
            } else {
                listCallbacksWithoutAnim.add(callback);
                Logs.debug("[Feedbacks] callback added to listCallbacksWithoutAnim for anim " + callback.animId());
            }
        }
        if ("stopped".equals(callback.type())) {
            tmpList = findAnim(listStartedAnimations, callback.animId());
            if (tmpList != null) {
                tmpList.setStoppedTime(callback.time());
                listStoppedAnimations.add(tmpList);
                listStartedAnimations.remove(tmpList);
            }
        }
        if ("end".equals(callback.type())) {
            tmpList = findAnim(listStartedAnimations, callback.animId());
            if (tmpList != null) {
                tmpList.setEndTime(callback.time());
                listStoppedAnimations.add(tmpList);
                listStartedAnimations.remove(tmpList);
            }
        }

        for (FeedbackPerformer feedbackPerformer : listFeedbackPerformer) {
            feedbackPerformer.performFeedback(callback);
        }
        Logs.debug("[Feedbacks] Callback received. Type: \"" + callback.type() + "\" Time: " + callback.time() + " Id: \"" + callback.animId() + "\" Timer: " + Timer.getTimeMillis());
    }
    /*
     * This function find an animation in the pending, dead, started, stopped or
     * ended list using animation id.
     */

    private TemporizableList findAnim(List<TemporizableList> listAnimation, ID Id) {
        for (TemporizableList tmpList : listAnimation) {
            if (tmpList.getID()==Id) {
                return tmpList;
            }
        }
        return null;
    }

    private Callback findCallback(ID animId) {
        for (Callback cback : listCallbacksWithoutAnim) {
            if (animId == cback.animId()) {
                return cback;
            }
        }
        return null;
    }

    @Override
    public synchronized void addFeedbackPerformer(FeedbackPerformer performer) {
        listFeedbackPerformer.add(performer);
    }

    @Override
    public synchronized void removeFeedbackPerformer(FeedbackPerformer performer) {
        listFeedbackPerformer.remove(performer);
    }

    @Override
    public void performSignals(List<Signal> list, ID requestId, Mode mode) {
        performAnimation(list, requestId);
    }

    @Override
    public void performIntentions(List<Intention> list, ID requestId, Mode mode) {
        performAnimation(list, requestId);
    }
    
        @Override
    public void addSignalPerformer(SignalPerformer sp) {
        signal_performers.add(sp);
    }

    @Override
    public void removeSignalPerformer(SignalPerformer sp) {
        signal_performers.remove(sp);
    }

   

}
